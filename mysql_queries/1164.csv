( SELECT l.product_id,r.new_price price from (SELECT product_id,max(change_date) recent_date from products where change_date<="2019-08-16" group by product_id) l inner join products r on l.product_id=r.product_id and l.recent_date=r.change_date) union all (SELECT product_id, 10 price from ( SELECT product_id,min(change_date) mini from products group by product_id) t where mini>"2019-08-16" )
( select product_id,10 as price from products group by product_id having min(change_date)>'2019-08-16' ) union all ( select product_id,price from( select product_id, new_price as price, dense_rank()over(partition by product_id order by change_date desc) as changerank from products where change_date<='2019-08-16' )a where changerank=1 )
(SELECT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Products WHERE change_date<='2019-08-16')) UNION (SELECT product_id,new_price AS price FROM (SELECT *, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC ) as rk FROM Products WHERE change_date<='2019-08-16')a WHERE rk =1)
(select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16') union (select product_id, new_price as price from products where (product_id, change_date) in (select product_id, max(change_date) as change_date1 from products where change_date <= '2019-08-16' group by product_id) )
(select product_id, new_price as price from (select product_id, new_price, row_number() over (partition by product_id order by change_date desc ) as ranks from Products where change_date='2019-08-16' or change_date<'2019-08-16') as t where ranks = 1) union (select product_id, case when change_date >'2019-08-16' then 10 else new_price end from Products group by product_id having MiN(change_date)>'2019-08-16')
CASE WHEN rk IS NULL THEN 10 ELSE tmp.new_price END AS price FROM ( SELECT DISTINCT product_id FROM Products) p LEFT JOIN ( SELECT product_id, new_price, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) rk FROM Products WHERE change_date <= '2019-08-16' ) tmp ON p.product_id = tmp.product_id AND rk = 1
SELECT * FROM ( SELECT product_id, new_price as price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) UNION SELECT DISTINCT product_id, 10 as price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Products WHERE change_date <= '2019-08-16') ) union_results
SELECT * FROM (SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) UNION SELECT DISTINCT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Products WHERE change_date <= '2019-08-16') ) tmp
SELECT DISTINCT P0.product_id, IFNULL(temp.new_price, 10) AS 'price' FROM Products P0 LEFT JOIN (SELECT * FROM Products P1 WHERE (P1.product_id, P1.change_date) IN (SELECT P2.product_id, MAX(P2.change_date) FROM Products P2 WHERE P2.change_date <= '2019-08-16' GROUP BY P2.product_id)) temp ON P0.product_id = temp.product_id
SELECT DISTINCT P2.product_id, IFNULL(new_price, 10) price FROM (SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) P1 RIGHT JOIN (SELECT product_id FROM Products) P2 ON P1.product_id = P2.product_id
SELECT DISTINCT a.product_id, IFNULL(temp.new_price, 10) AS price FROM products AS a LEFT JOIN( SELECT * FROM products WHERE (product_id, change_date) IN( SELECT product_id, MAX(change_date) FROM products WHERE change_date <= "2019-08-16" GROUP BY product_id )) AS temp ON a.product_id = temp.product_id
SELECT DISTINCT a.product_id, coalesce(b.new_price, 10) as price FROM products as a left join ( select product_id, rank() over(partition by product_id order by change_date desc) as xrank, new_price from products where change_date <= '2019-08-16' ) as b on a.product_id = b.product_id and b.xrank = 1 order by 2 desc
SELECT DISTINCT p.product_id, COALESCE(c.new_price, 10) AS price FROM products p LEFT JOIN ( SELECT * FROM ( SELECT *, MAX(change_date) OVER (PARTITION BY product_id) AS max_date FROM products WHERE change_Date <= '2019-08-16' ) m WHERE max_date = change_Date ) c ON p.product_id = c.product_id
SELECT DISTINCT p.product_id, COALESCE(t.new_price, 10) AS price FROM Products p LEFT JOIN ( SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) AS most_recent_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ) ) t ON p.product_id=t.product_id
SELECT DISTINCT p.product_id, IFNULL(b.new_price, 10) AS price FROM Products p LEFT JOIN (SELECT a.product_id, a.new_price FROM (SELECT product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS num FROM Products WHERE change_date <= '2019-08-16') a WHERE a.num = 1) b ON p.product_id = b.product_id
SELECT DISTINCT p.product_id, IFNULL(t.new_price, 10) AS price FROM Products AS p LEFT JOIN (SELECT product_id,new_price, RANK()OVER(PARTITION BY product_id ORDER BY change_date DESC) AS rk FROM Products WHERE change_date <= '2019-08-16' ) AS t ON p.product_id = t.product_id AND rk =1
SELECT DISTINCT p.product_id, IFNULL(t.new_price, 10) AS price FROM Products p LEFT JOIN (SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <='2019-08-16' GROUP BY product_id)) t ON p.product_id = t.product_id
SELECT DISTINCT p.product_id, IFNULL(temp.new_price, 10) AS price FROM (SELECT * FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) temp RIGHT JOIN Products p USING (Product_id)
SELECT DISTINCT p.product_id, IFNULL(temp.new_price,10) price FROM Products p LEFT JOIN (SELECT * FROM Products p WHERE (product_id,change_date) IN (SELECT product_id, MAX(change_date) change_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) temp ON p.product_id = temp.product_id
SELECT DISTINCT p.product_id, ifnull(a.new_price,10) AS price FROM Products p LEFT JOIN ( SELECT product_id,new_price FROM ( SELECT product_id,new_price, row_number() over (PARTITION BY product_id ORDER BY change_date DESC) AS rn FROM Products WHERE change_date<'2019-08-17' ) AS xx WHERE xx.rn = 1 ) a ON p.product_id = a.product_id
SELECT DISTINCT p.product_id,IF(t.latest IS NULL,10,new_price) AS price FROM Products p LEFT JOIN (SELECT product_id,MAX(change_date) AS latest FROM Products WHERE change_date<='2019-08-16' group by 1) t ON p.product_id=t.product_id WHERE p.change_date=t.latest OR t.latest IS NULL
SELECT DISTINCT p.product_id,ifnull(b.price,10) AS price From Products p Left JOIN (SELECT product_id,a.price FROM (SELECT product_id,new_price price, rank() over (partition by product_id order by (datediff("2019-08-16",change_date))) num FROM Products WHERE change_date<="2019-08-16")a WHERE a.num=1)b ON p.product_id=b.product_id
SELECT DISTINCT p1.product_id, COALESCE(p2.new_price, 10) AS price FROM Products AS p1 LEFT JOIN (SELECT * FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) AS p2 ON p1.product_id = p2.product_id
SELECT DISTINCT p1.product_id, COALESCE(p2.new_price,10) price FROM products p1 LEFT JOIN (SELECT product_id, new_price, rank() OVER(PARTITION BY product_id ORDER BY change_date DESC) rnk FROM products WHERE change_date<='2019-08-16') p2 ON p1.product_id=p2.product_id AND rnk=1
SELECT DISTINCT p1.product_id, IFNULL(p2.new_price, 10) AS price FROM Products p1 LEFT JOIN ( SELECT * FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) p2 ON p1.product_id = p2.product_id
SELECT DISTINCT p1.product_id, IFNULL(p2.new_price,10) AS price FROM Products p1 LEFT JOIN (SELECT product_id, new_price, change_date FROM Products WHERE (product_id,change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) ) p2 ON p1.product_id = p2.product_id
SELECT DISTINCT p1.product_id, IFNULL(p2.price, 10) AS price FROM products AS p1 LEFT JOIN (SELECT product_id, new_price AS price FROM (SELECT *, DENSE_RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS DatesRank FROM Products WHERE change_date <= DATE("2019-08-16")) AS tmp WHERE tmp.DatesRank = 1) AS p2 ON p1.product_id = p2.product_id
SELECT DISTINCT p1.product_id,ifnull(temp.new_price,10) as price FROM Products p1 LEFT JOIN ( SELECT * FROM Products p2 WHERE (p2.product_id, p2.change_date) IN ( SELECT product_id, MAX(change_date) AS recent_date FROM Products WHERE change_date <= "2019-08-16" GROUP BY 1) ) AS temp ON p1.product_id = temp.product_id
SELECT DISTINCT product_id, 10 AS price FROM Products GROUP BY product_id HAVING (MIN(change_date) > "2019-08-16") UNION SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) AS recent_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)
SELECT DISTINCT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date) > "2019-08-16" UNION SELECT DISTINCT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT DISTINCT product_id, MAX(change_date) AS recent_change_date FROM Products WHERE change_date <= "2019-08-16" GROUP BY product_id )
SELECT DISTINCT product_id, ifnull(t.new_price, 10) price FROM Products LEFT JOIN (SELECT * FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) GROUP BY product_id) t USING(product_id)
SELECT DISTINCT product_id, new_price AS price FROM (SELECT *, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) max_date_rnk FROM Products WHERE change_date <= '2019-08-16') t WHERE max_date_rnk = 1 UNION SELECT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT DISTINCT product_id FROM Products WHERE change_date <= "2019-08-16")
SELECT DISTINCT t1.product_id, IFNULL(t3.new_price,10) AS price FROM Products t1 LEFT JOIN ( SELECT product_id, new_price FROM ( SELECT *,RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS rank_date FROM Products WHERE change_date <='2019-08-16') t2 WHERE rank_date = 1) t3 USING(product_id)
SELECT DISTINCT(p.product_id), IFNULL(temp.new_price,10) AS price FROM Products p LEFT JOIN ( SELECT * FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ) ) temp ON p.product_id = temp.product_id
SELECT DISTINCT(product_id), LAST_VALUE(new_price) OVER(PARTITION BY product_id order by change_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS FINAL_PRICE FROM Products WHERE change_date <= '2019-08-16' ) SELECT product_id, FINAL_PRICE AS price FROM LAST_VALUE_TABLE UNION ALL SELECT DISTINCT(product_id) , 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM LAST_VALUE_TABLE)
SELECT PRODUCT_ID, NEW_PRICE AS PRICE FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY PRODUCT_ID ORDER BY CHANGE_DATE DESC) AS LATEST FROM PRODUCTS WHERE CHANGE_DATE <= '2019-08-16') A WHERE A.LATEST = 1 UNION SELECT PRODUCT_ID, 10 AS PRICE FROM PRODUCTS GROUP BY PRODUCT_ID HAVING MIN(CHANGE_DATE) > '2019-08-16'
SELECT Products.product_id, ifnull(p.price, 10) as price FROM Products LEFT JOIN (SELECT product_id, new_price as price FROM (SELECT product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) as rnk FROM Products WHERE change_date<='2019-08-16' ) as r WHERE rnk=1) as p ON Products.product_id=p.product_id GROUP BY Products.product_id, price
SELECT T1.product_id, IFNULL(T2.new_price,10) AS price FROM (SELECT DISTINCT product_id FROM Products) AS T1 LEFT JOIN (SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) AS last_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) AS T2 ON T1.product_id = T2.product_id
SELECT T1.product_id, IFNULL(T2.new_price,10) AS price FROM (SELECT DISTINCT product_id FROM Products) AS T1 LEFT JOIN (SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) AS last_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) AS T2 ON T1.product_id = T2.product_id order by price
SELECT TL.product_id, IFNULL(new_price, 10) price FROM (SELECT DISTINCT(product_id) AS product_id FROM Products) AS TL LEFT JOIN (SELECT * FROM(SELECT *, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) RNK FROM Products WHERE change_date <= "2019-08-16") AS PT WHERE RNK = 1) AS TR ON TL.product_id = TR.product_id ORDER BY product_id
SELECT a.product_id , b.new_price AS 'price' FROM ( SELECT product_id , MAX(change_date) AS 'max_changedate' FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ) a LEFT JOIN Products b ON a.product_id=b.product_id AND a.max_changedate=b.change_date UNION SELECT product_id, 10 AS 'price' FROM Products WHERE product_id NOT IN ( SELECT product_id FROM ( SELECT product_id , MAX(change_date) AS 'max_changedate' FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) a )
SELECT a.product_id, COALESCE(b.price, 10) AS price FROM (SELECT DISTINCT product_id FROM products) a LEFT JOIN ( SELECT product_id, price FROM ( SELECT product_id, new_price AS price, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS rn FROM products WHERE change_date <= '2019-08-16' ) t WHERE rn = 1 ) b ON a.product_id = b.product_id
SELECT a.product_id, IFNULL(b.new_price, 10) AS price FROM Products a LEFT JOIN ( SELECT product_id, new_price FROM ( SELECT product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS r FROM Products WHERE change_date <= '2019-08-16' ) t WHERE r = 1 ) b ON a.product_id = b.product_id GROUP BY a.product_id
SELECT c.product_id, 10 AS price FROM products AS c GROUP BY product_id HAVING min(change_date) > "2019-08-16" UNION SELECT b.product_id, b.new_price FROM products AS b WHERE (b.product_id, b.change_date) in (SELECT product_id, max(change_date) AS max_d FROM products WHERE change_date <="2019-08-16" GROUP BY product_id)
SELECT distinct a.product_id,ifnull(temp.new_price,10) as price FROM products as a LEFT JOIN (SELECT * FROM products WHERE (product_id, change_date) in ( select product_id,max(change_date) from products where change_date<="2019-08-16" group by product_id)) as temp on a.product_id = temp.product_id
SELECT distinct a.product_id,ifnull(temp.new_price,10) as price FROM products as a LEFT JOIN (SELECT * FROM products WHERE (product_id, change_date) in (select product_id,max(change_date) from products where change_date<="2019-08-16" group by product_id)) as temp on a.product_id = temp.product_id
SELECT m.product_id, COALESCE(q.new_price, 10) AS price FROM ( SELECT * FROM products WHERE change_date <= '2019-08-16' ) AS q LEFT JOIN ( SELECT * FROM products WHERE change_date <= '2019-08-16' ) AS qq ON q.product_id = qq.product_id AND q.change_date < qq.change_date RIGHT JOIN ( SELECT DISTINCT(product_id) AS product_id FROM products ) AS m ON q.product_id = m.product_id WHERE qq.change_date IS NULL
SELECT p.product_id, CASE WHEN rk IS NULL THEN 10 ELSE tmp.new_price END AS price FROM ( SELECT DISTINCT product_id FROM Products) p LEFT JOIN ( SELECT product_id, new_price, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) rk FROM Products WHERE change_date <= '2019-08-16' ) tmp ON p.product_id = tmp.product_id AND rk = 1
SELECT p.product_id, MAX(CASE WHEN m.product_id IS NULL THEN 10 ELSE new_price END) AS price FROM products p LEFT JOIN (SELECT product_id, MAX(change_date) AS max_date FROM products p WHERE change_date <= '2019-08-16' GROUP BY product_id) m ON p.product_id = m.product_id AND p.change_date = m.max_date GROUP BY product_id
SELECT p1.product_id, CASE WHEN a.new_price IS NULL THEN 10 ELSE a.new_price END AS price FROM products p1 LEFT JOIN (SELECT p.product_id, p.new_price FROM (SELECT product_id, new_price, change_date, RANK()OVER(Partition by product_id Order by change_date DESC) AS rnk FROM products WHERE change_date <= '2019-08-16' )p WHERE p.rnk = 1 )a ON p1.product_id = a.product_id GROUP BY p1.product_id
SELECT p1.product_id, p1.new_price price FROM Products p1 JOIN ( SELECT p2.product_id prod, MAX(p2.change_date) latest FROM Products p2 WHERE change_date <= DATE('2019-08-16') GROUP BY product_id) tbl1 ON p1.product_id = tbl1.prod AND p1.change_date = tbl1.latest UNION ALL SELECT p3.product_id, 10 FROM Products p3 GROUP BY product_id HAVING MIN(change_date) > DATE('2019-08-16')
SELECT pro.product_id, COALESCE(pri.new_price, 10) AS price FROM ( SELECT DISTINCT product_id FROM Products ) pro LEFT OUTER JOIN ( SELECT product_id, new_price, DENSE_RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS price_rank FROM Products WHERE change_date <= '2019-08-16' ) pri ON pro.product_id = pri.product_id AND price_rank = 1
SELECT product_id ,10 AS price FROM Products GROUP BY 1 HAVING MIN(change_date) > '2019-08-16' UNION ALL SELECT product_id ,new_price AS price FROM Products WHERE (product_id,change_date) IN (SELECT product_id,MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY 1)
SELECT product_id ,new_price as Price FROM ( SELECT a.product_id ,new_price ,DENSE_RANK() OVER (Partition BY product_id ORDER BY change_date DESC) as DenseRank FROM Products a WHERE 1=1 AND a.change_date <= '2019-08-16' ) t WHERE 1=1 AND DenseRank = 1 UNION SELECT product_id ,10 as Price FROM Products a WHERE 1=1 AND product_id NOT IN ( SELECT product_id FROM Products WHERE change_date <= '2019-08-16' )
SELECT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date) > '2019-08-16' UNION SELECT product_id, new_price AS price FROM Products WHERE (product_id,change_date) IN( SELECT product_id, max(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)
SELECT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date) > '2019-08-16' UNION SELECt distinct t.product_id, t.new_price from Products t where (t.product_id, t.change_date) in (select product_id,max(change_date) as recent_date from Products where change_date <='2019-08-16' group by product_id )
SELECT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date) > DATE('2019-08-16') UNION SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= DATE('2019-08-16') GROUP BY product_id)
SELECT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date)>'2019-08-16' UNION SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id )
SELECT product_id, FIRST_VALUE(new_price) OVER(PARTITION BY product_id ORDER BY change_date DESC) as price FROM Products WHERE change_date <='2019-08-16' UNION SELECT DISTINCT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Products WHERE change_date <='2019-08-16')
SELECT product_id, IFNULL(new_price, 10) AS price FROM ( SELECT DISTINCT t1.product_id, t2.new_price FROM Products t1 LEFT JOIN ( SELECT * FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= "2019-08-16" GROUP BY product_id ) ) t2 ON t1.product_id = t2.product_id ) t ORDER BY price DESC
SELECT product_id, IFNULL(new_price, 10) AS price FROM (SELECT DISTINCT product_id FROM products) t1 LEFT JOIN (SELECT * FROM (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk FROM products WHERE change_date <= '2019-08-16') t2 WHERE rnk = 1) t3 USING(product_id)
SELECT product_id, IFNULL(new_price,10) AS price FROM ( SELECT DISTINCT t1.product_id, t3.new_price FROM Products t1 LEFT JOIN ( SELECT product_id, new_price FROM ( SELECT *,RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS rank_date FROM Products WHERE change_date <='2019-08-16') t2 WHERE rank_date = 1) t3 USING(product_id) ) t4
SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) UNION SELECT DISTINCT product_id, 10 FROM Products GROUP BY Product_id HAVING MIN(change_date) > '2019-08-16'
SELECT product_id, new_price as price FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS latest FROM Products WHERE change_date <= '2019-08-16') new WHERE new.latest = 1 UNION SELECT product_id, 10 as price FROM Products GROUP BY product_id HAVING MIN(change_date) > '2019-08-16'
SELECT product_id, new_price price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ) UNION SELECT product_id, 10 price FROM Products WHERE product_id NOT IN ( SELECT product_id FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id )
SELECT product_id, new_price price FROM products WHERE (product_id, change_date) in (SELECT product_id,max(change_date) FROM Products WHERE change_date <='2019-08-16' GROUP BY product_id) UNION select product_id, 10 AS price FROM products group by PRODUCT_ID HAVING MIN(CHANGE_DATE)> '2019-08-16'
SELECT product_id, price FROM (SELECT product_id, new_price as price, change_date, rank() over (PARTITION BY product_id ORDER BY change_date DESC) AS r FROM Products WHERE change_date <= '2019-08-16') as a WHERE r = 1 UNION ALL SELECT product_id, 10 AS price FROM Products GROUP BY product_id HAVING MIN(change_date) > '2019-08-16'
SELECT product_id,10 as price From Products Group By product_id Having min(change_date>"2019-08-16") UNION ALL SELECT product_id,new_price as price From Products Where(product_id, change_date) in (SELECT product_id,MAX(change_date) from Products where change_date<="2019-08-16" Group by product_id) Group by product_id HAVING max(change_date)<="2019-08-16"
SELECT sub1.product_id, COALESCE(sub2.new_price, 10) as price FROM(SELECT DISTINCT product_id FROM Products) sub1 LEFT JOIN (SELECT product_id, new_price, ROW_NUMBER() over(partition by product_id order by change_date desc) as ranked FROM Products Where change_date <= "2019-08-16") sub2 ON sub1.product_id = sub2.product_id WHERE sub2.ranked=1 or sub2.ranked is null
SELECT t2.product_id, IFNULL(t1.new_price, 10) AS price FROM (SELECT DISTINCT product_id FROM products p) t2 LEFT JOIN (SELECT p.product_id, p.new_price FROM Products p JOIN (SELECT product_id, MAX(change_date) AS newest_date FROM Products p WHERE change_date <= '2019-08-16' GROUP BY 1) t ON p.change_date = t.newest_date AND p.product_id = t.product_id) t1 ON t2.product_id = t1.product_id
SELECT temp.product_id, temp.new_price as price FROM (SELECT product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY Change_date DESC) as daterank FROM Products WHERE datediff(change_date,'2019-08-16')<=0) as temp where temp.daterank =1 UNION ALL SELECT DISTINCT product_id, 10 as price FROM Products WHERE datediff(change_date,'2019-08-16')>0 AND product_id not in (SELECT DISTINCT product_id FROM Products WHERE datediff(change_date,'2019-08-16')<=0)
SELECT tmp.product_id,IFNULL(tmp1.price,10) as price FrOM (SELECT DISTINCT product_id FROM Products) AS tmp LeFT JOIN ( SELECT P.product_id,P.new_price as price FROM Products AS P JOIN (SELECT product_id,max(change_date) as maxd FROM Products WHERE change_date<='2019-08-16' gROUP BY product_id) AS new On p.product_id=new.product_id and p.change_date=new.maxd) aS tmp1 ON tmp.product_id=tmp1.product_id
Select E.product_id, Coalesce(D.new_price,10) as Price from (select Distinct product_id from products) E left join (Select B.product_id, B.change_date, C.new_price from (select A.product_id, max(A.change_date) as change_date from (select * from products where change_date <= '2019-08-16' ) A group by A.Product_id) B left join Products C on B.product_id = C.product_id and B.Change_date = C.change_date ) D on E.product_id = D.product_id
Select Product_ID , price From (Select Product_ID , new_price as Price , rank() Over(partition by product_ID Order by change_date desc) as rnk From Products Where change_date <= '2019-08-16') a Where rnk = 1 Union Select Product_ID , 10 From Products Where product_ID not in (Select Product_ID From Products Where change_date <= '2019-08-16')
Select Product_ID, price From (Select Product_ID , new_price as Price , rank() Over(partition by product_ID Order by change_date desc) as rnk From Products Where change_date <= '2019-08-16') a Where rnk = 1 Union Select Product_ID, 10 From Products Where product_ID not in (Select Product_ID From Products Where change_date <= '2019-08-16')
Select product_id, new_price as price From (SELECT *, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS latest FROM Products Where change_date < '2019-08-17') new Where new.latest = 1 Union Select product_id, 10 as price From Products group by product_id Having min(change_date) > '2019-08-16'
Select product_id, new_price as price from Products where (product_id, change_date) in (Select product_id, max(change_date) from Products where change_date <='2019-08-16' group by 1) union Select distinct product_id, 10 as price from Products group by 1 having min(change_date) > '2019-08-16'
Select t1.product_id, new_price as price From Products t1 Join (Select product_id, max(change_date) as last_date From Products Where change_date <= '2019-08-16' Group By product_id) t2 on t1.product_id = t2.product_id and change_date = last_date union select distinct product_id, 10 as price from Products group by product_id having (min(change_date) > "2019-08-16")
WITH C AS ( SELECT * FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date<="2019-08-16" GROUP BY product_id ) ) SELECT DISTINCT a.product_id, IFNULL(C.new_price,10) AS price FROM products AS a LEFT JOIN C ON a.product_id = C.product_id
WITH CTE AS ( SELECT DISTINCT product_id, last_value(new_price) OVER (PARTITION BY product_id ORDER BY change_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS price FROM (SELECT * FROM Products WHERE change_date<="2019-08-16") AS list ) SELECT P.product_id, COALESCE(price,10) AS price FROM (SELECT DISTINCT product_id FROM Products) AS P LEFT JOIN CTE AS C USING(product_id)
WITH CTE AS ( SELECT product_id, new_price AS price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) as r FROM Products WHERE change_date <= '2019-08-16' ) SELECT product_id, price FROM CTE WHERE r = 1 UNION ALL SELECT DISTINCT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM CTE)
WITH CTE AS( SELECT product_id, new_price, change_date, RANK() OVER(partition by product_id order by change_date DESC) AS ranking FROM Products WHERE change_date <= '2019-08-16') SELECT a.product_id, CASE WHEN CTE.product_id IS NULL THEN 10 ELSE CTE.new_price END AS price FROM Products a LEFT JOIN CTE ON a.product_id = CTE.product_id AND ranking = 1 GROUP BY a.product_id
WITH CTE AS(SELECT product_id, new_price AS price FROM (SELECT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS ranking FROM Products WHERE change_date <= '2019-08-16') sub WHERE ranking = 1) SELECT product_id,COALESCE(price, 10) AS price FROM CTE RIGHT JOIN Products USING (product_id) GROUP BY product_id ORDER BY product_id
WITH CTE as (select product_id,new_price,change_Date, RANK() OVER(PARTITION BY product_id ORDER BY change_Date DESC) as prod_rank from Products where change_date <= '2019-08-16' ) SELECT DISTINCT P.product_id, IFNULL(C.new_price,10) as price from Products P left outer join CTE C ON P.product_id = c.product_id and prod_rank =1
WITH Dates AS ( SELECT product_id, MAX(change_date) AS change_date FROM Products WHERE DATEDIFF('2019-08-16', change_date)>=0 GROUP BY product_id ), Prices AS ( SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN (SELECT * FROM Dates) ), Ids AS ( SELECT DISTINCT product_id FROM Products ) SELECT product_id, COALESCE(price,10) AS price FROM Ids LEFT JOIN Prices USING(product_id)
WITH PRODUCT_PRICE AS( SELECT PRODUCT_ID, NEW_PRICE AS PRICE, RANK() OVER(PARTITION BY PRODUCT_ID ORDER BY CHANGE_DATE DESC) AS RN FROM PRODUCTS WHERE CHANGE_DATE<='2019-08-16' ), PROD AS( SELECT DISTINCT PRODUCT_ID FROM PRODUCTS ) SELECT P.PRODUCT_ID, IFNULL(PC.PRICE,10) AS PRICE FROM PROD P LEFT JOIN PRODUCT_PRICE PC ON P.PRODUCT_ID=PC.PRODUCT_ID AND RN=1
WITH S0 AS (SELECT DISTINCT(product_id) AS product_id, 10 AS price FROM Products), S1 AS (SELECT product_id, new_price, change_date FROM Products WHERE change_date <= '2019-08-16'), S2 AS (SELECT product_id, MAX(change_date) AS latest_change_date FROM S1 GROUP BY product_id), S3 AS (SELECT S2.product_id, new_price AS price FROM S2 INNER JOIN Products ON S2.product_id = Products.product_id AND S2.latest_change_date = Products.change_date) SELECT S0.product_id, IFNULL(S3.price,S0.price) AS price FROM S0 LEFT JOIN S3 ON S0.product_id = S3.product_id
WITH TEMP AS (SELECT PRODUCT_ID, NEW_PRICE AS PRICE, RANK() OVER (PARTITION BY PRODUCT_ID ORDER BY CHANGE_DATE DESC) AS RNK FROM PRODUCTS WHERE CHANGE_DATE<='2019-08-16') SELECT P.PRODUCT_ID, COALESCE(T.PRICE,10) AS PRICE FROM (SELECT DISTINCT PRODUCT_ID FROM PRODUCTS) P LEFT OUTER JOIN TEMP T ON P.PRODUCT_ID = T.PRODUCT_ID AND T.RNK = 1 ORDER BY 1
WITH Table_1 AS ( SELECT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) as rnk FROM Products WHERE change_date <= '2019-08-16' ) SELECT DISTINCT Products.product_id, CASE WHEN Table_1.new_price IS NULL THEN 10 ELSE Table_1.new_price END AS price FROM Products LEFT JOIN Table_1 ON Products.product_id=Table_1.product_id AND rnk=1
WITH Table_1 AS ( SELECT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) as rnk FROM Products WHERE change_date <= '2019-08-16' ) SELECT product_id, new_price as price FROM Table_1 WHERE rnk=1 UNION SELECT product_id, 10 from Products WHERE product_id not in (Select distinct product_id from Table_1)
WITH change_table AS (SELECT product_id, new_price as changed_price, row_number() OVER (PARTITION BY product_id ORDER by change_date DESC) as recency FROM products AS p WHERE change_date <= "2019-08-16") select distinct p1.product_id, coalesce(ct.changed_price, 10) as price FROM products AS p1 LEFT JOIN change_table AS ct ON p1.product_id = ct.product_id AND ct.recency = 1
WITH cte AS ( SELECT product_id, MAX(change_date) AS md FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) SELECT DISTINCT a.product_id, CASE WHEN b.md IS NULL THEN 10 ELSE IFNULL(new_price, 10) END AS price FROM products a LEFT JOIN cte b ON a.product_id = b.product_id WHERE a.change_date = b.md OR b.md IS NULL
WITH cte AS (SELECT DISTINCT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS rnk FROM Products WHERE change_date<='2019-08-16') SELECT DISTINCT P.product_id, COALESCE(cte.new_price,10) AS price FROM Products P LEFT JOIN cte ON P.product_id=cte.product_id AND rnk=1
WITH cte AS (SELECT product_id, new_price, change_date, MAX(change_date) OVER (PARTITION BY product_id) AS max_date FROM Products WHERE change_date <= "2019-08-16") SELECT DISTINCT product_id, IFNULL(T.new_price, 10) AS price FROM Products LEFT JOIN (SELECT * FROM cte WHERE change_date = max_date) AS T USING(product_id)
WITH cte AS (SELECT product_id, new_price, rank() OVER(PARTITION BY product_id ORDER BY change_date DESC) rnk FROM products WHERE change_date<='2019-08-16' ) SELECT DISTINCT p.product_id, COALESCE(c.new_price,10) AS price FROM products p LEFT JOIN cte c ON p.product_id = c.product_id AND rnk = 1
WITH cte AS( SELECT DISTINCT product_id, new_price, change_date, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS "rank" FROM Products WHERE change_date <= '2019-08-16') SELECT DISTINCT p.product_id, IFNULL(c.new_price, 10) AS price FROM Products p LEFT JOIN cte c ON (p.product_id = c.product_id AND c.rank = 1)
WITH cte AS( SELECT product_id, LAST_VALUE(new_price) OVER(PARTITION BY product_id ORDER BY DATE(change_date) ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS final_price FROM Products WHERE DATE(change_date) <= '2019-08-16' ) SELECT DISTINCT P.product_id, IF(cte.final_price IS NULL, 10, cte.final_price) AS price FROM Products P LEFT JOIN cte on cte.product_id = P.product_id
WITH date_change AS (SELECT product_id, MAX(change_date) as date_change FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) SELECT DISTINCT p.product_id, (CASE WHEN d.date_change IS NULL THEN 10 ELSE p.new_price END) as price FROM Products p LEFT JOIN date_change d ON p.product_id = d.product_id WHERE (p.change_date = d.date_change OR d.date_change IS NULL)
WITH date_window AS ( SELECT * FROM ( SELECT change_date, product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) as rk FROM PRODUCTS WHERE change_date <= '2019-08-16' ) tt WHERE rk = 1 ), full_view AS ( SELECT DISTINCT product_id as product_listing, 10 as default_price FROM Products ) SELECT CASE WHEN product_id IS NULL THEN product_listing ELSE product_id END as product_id, CASE WHEN new_price is NULL THEN default_price ELSE new_price END as price FROM date_window dw RIGHT JOIN full_view fv ON dw.product_id = fv.product_listing
WITH last_change AS ( SELECT product_id, MAX(change_date) as last_change FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ), soln AS ( SELECT ids.product_id, COALESCE(p.new_price, 10) AS price FROM (SELECT distinct product_id FROM products) ids LEFT JOIN last_change lc ON ids.product_id = lc.product_id LEFT JOIN Products p ON lc.product_id = p.product_id AND lc.last_change = p.change_date ) SELECT * FROM soln
WITH most_recent_change_dates AS ( SELECT product_id, MAX(change_date) AS most_recent_change FROM Products WHERE change_date <= "2019-08-16" GROUP BY product_id ) SELECT z1.product_id, IFNULL(price, 10) AS price FROM (SELECT DISTINCT product_id FROM products) z1 LEFT JOIN ( SELECT p.product_id, new_price as price FROM products p LEFT JOIN most_recent_change_dates m ON p.product_id = m.product_id WHERE change_date = most_recent_change ) z2 ON z1.product_id = z2.product_id
WITH new_price AS ( SELECT product_id, new_price, rank() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rk FROM Products WHERE change_date<='2019-08-16' ) SELECT DISTINCT Products.product_id, CASE WHEN new_price.new_price IS NULL THEN 10 ELSE new_price.new_price END AS price FROM Products LEFT JOIN new_price ON Products.product_id=new_price.product_id AND rk=1
WITH pre_16 AS ( SELECT *, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) date_rank FROM Products WHERE change_date <= '2019-08-16') (SELECT DISTINCT p.product_id, IFNULL(pre_16.new_price, 10) as price FROM Products p LEFT JOIN pre_16 ON p.product_id = pre_16.product_id WHERE date_rank = 1) UNION ALL (SELECT DISTINCT product_id, 10 as price FROM Products WHERE product_id not in (select product_id FROM pre_16))
WITH pricechange_id AS (SELECT product_id, MAX(change_date) date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id) SELECT distinct product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN (SELECT * FROM pricechange_id) UNION SELECT product_id, 10 FROM Products WHERE product_id NOT IN (SELECT product_id FROM pricechange_id)
WITH prod_ids as ( SELECT product_id FROM Products GROUP BY product_id), t1 as ( SELECT * FROM ( SELECT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) as prod_rank FROM products WHERE change_date < 20190817) temp WHERE prod_rank = 1) SELECT p.product_id, CASE WHEN t.new_price IS NOT NULL THEN t.new_price ELSE 10 END as price FROM prod_ids p LEFT JOIN t1 t ON p.product_id = t.product_id
WITH product_rows AS ( SELECT *, ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rn FROM Products WHERE change_date <= '2019-08-16' ) SELECT p.product_id, COALESCE(MAX(CASE WHEN pr.rn = 1 THEN p.new_price END), 10) AS price FROM Products AS p LEFT JOIN product_rows AS pr ON p.product_id = pr.product_id AND p.change_date = pr.change_date GROUP BY p.product_id
WITH products_before AS (SELECT product_id, MAX(change_date) as date FROM (SELECT * FROM Products WHERE change_date<= '2019-08-16') as t GROUP BY 1), price_before AS (SELECT a.product_id, b.new_price FROM products_before a LEFT JOIN Products b ON a.product_id = b.product_id AND a.date = b.change_date) SELECT a.product_id, CASE WHEN new_price IS NULL THEN 10 ELSE new_price END AS price FROM (SELECT DISTINCT product_id FROM Products) a LEFT JOIN price_before b ON a.product_id = b.product_id
WITH r AS ( SELECT product_id, new_price AS price, rank() over (PARTITION BY product_id ORDER BY change_date DESC) rnk FROM products WHERE change_date < '2019-08-17' ), t AS ( SELECT DISTINCT product_id FROM products ), s AS ( SELECT * FROM r WHERE rnk = 1 ) SELECT t.product_id, COALESCE(s.price, 10) AS price FROM t LEFT JOIN s ON t.product_id = s.product_id
WITH rank1 AS (SELECT *, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk FROM Products WHERE change_date<= "2019-08-16"), rank2 AS (SELECT product_id, new_price FROM rank1 WHERE rnk = 1) SELECT p.product_id, IFNULL(r.new_price, 10) AS price FROM Products p LEFT JOIN rank2 r ON p.product_id = r.product_id GROUP BY 1,2
WITH ranked_data AS ( SELECT product_id, new_price, rank() OVER (PARTITION BY product_id ORDER BY change_date DESC ) as price_rank FROM Products WHERE change_date<'2019-08-17' ), product_unique as ( SELECT DISTINCT product_id from Products ) SELECT product_unique.product_id,COALESCE(ranked_data.new_price,10) as price FROM product_unique LEFT JOIN (SELECT * FROM ranked_data WHERE price_rank = 1) ranked_data ON ranked_data.product_id = product_unique.product_id
WITH rc AS( SELECT product_id ,new_price FROM ( SELECT product_id ,new_price ,ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY change_date DESC) recent_price_change FROM Products WHERE change_date <= '2019-08-16' ) AS rank_table WHERE recent_price_change = 1 ) , no_rc AS ( SELECT p.product_id , 10 AS price FROM Products p LEFT JOIN rc ON p.product_id = rc.product_id WHERE rc.product_id IS NULL GROUP BY 1 ) SELECT product_id ,new_price AS price FROM rc UNION SELECT product_id , price FROM no_rc
WITH rc AS( SELECT product_id ,new_price FROM ( SELECT product_id ,new_price ,ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY change_date DESC) recent_price_change FROM Products WHERE change_date <= '2019-08-16' ) AS rank_table WHERE recent_price_change = 1 ) , uni_rc AS ( SELECT p.product_id FROM Products p GROUP BY 1 ) SELECT uni_rc.product_id ,CASE WHEN rc.product_id = uni_rc .product_id THEN rc.new_price ELSE 10 END AS Price FROM uni_rc LEFT JOIN rc ON rc.product_id = uni_rc .product_id
WITH sub AS( SELECT product_id, new_price, RANK() OVER(PARTITION BY product_id ORDER BY change_date DESC) rnk FROM products WHERE change_date <= '2019-08-16') SELECT DISTINCT p.product_id, CASE WHEN sub.new_price IS NULL THEN 10 ELSE sub.new_price END as price FROM products p LEFT JOIN sub ON p.product_id = sub.product_id AND sub.rnk = 1
WITH t AS ( SELECT product_id, MAX(IF(change_date<='2019-08-16',change_date,NULL)) closest_date FROM products GROUP BY product_id ) SELECT p.product_id product_id, AVG( CASE WHEN ISNULL(t.closest_date) THEN 10 ELSE p.new_price END ) price FROM products p JOIN t ON p.product_id=t.product_id WHERE t.closest_date=p.change_date OR ISNULL(t.closest_date) GROUP BY p.product_id
WITH t AS ( SELECT product_id, MAX(change_date) AS change_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ), tt AS ( SELECT DISTINCT product_id, 10 AS price FROM Products ), tbl AS ( SELECT p.product_id, new_price AS price FROM Products p INNER JOIN t ON p.product_id = t.product_id AND p.change_date = t.change_date ) SELECT tt.product_id, COALESCE(tbl.price, tt.price) AS price FROM tt LEFT JOIN tbl ON tt.product_id = tbl.product_id
WITH t AS (SELECT product_id, MAX(change_date) AS change_date FROM (SELECT * FROM Products WHERE change_date <= '2019-08-16') k GROUP BY product_id), s AS ( SELECT DISTINCT product_id FROM Products) SELECT s.product_id, CASE WHEN a.new_price is not NULL THEN a.new_price ELSE 10 END AS price FROM s LEFT JOIN t ON s.product_id=t.product_id LEFT JOIN Products AS a ON t.product_id=a.product_id AND t.change_date=a.change_date
WITH t1 AS ( SELECT product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS date_rank FROM Products WHERE DATEDIFF(change_date, '2019-08-16') <= 0 ) SELECT t2.product_id, CASE WHEN t1.date_rank = 1 THEN t1.new_price ELSE 10 END AS price FROM (SELECT DISTINCT product_id FROM Products) t2 LEFT JOIN t1 ON t2.product_id = t1.product_id WHERE t1.date_rank = 1 OR t1.date_rank IS NULL
WITH t1 AS( SELECT product_id, MAX(change_date) AS recent_change FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id ), t2 AS( SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT * FROM t1) ), t3 AS( SELECT DISTINCT product_id FROM Products ) SELECT t3.product_id, IFNULL(t2.new_price,10) AS price FROM t3 LEFT JOIN t2 on t3.product_id = t2.product_id
WITH temp AS ( SELECT product_id, change_date, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk, new_price FROM Products WHERE change_date <= '2019-08-16' ) select product_id, new_price as price from temp where rnk = 1 UNION select product_id, 10 from Products where change_date > '2019-08-16' AND product_id NOT IN (SELECT distinct product_id FROM products where change_date <= '2019-08-16')
WITH temp AS ( SELECT product_id, change_date, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rnk, new_price FROM Products WHERE change_date <= '2019-08-16' ) select product_id, new_price as price from temp where rnk = 1 UNION select product_id, 10 from Products where product_id NOT IN (SELECT distinct product_id FROM products where change_date <= '2019-08-16')
With a as ( Select t1.product_id, new_price From Products t1 Join (Select product_id, max(change_date) as last_date From Products Where change_date <= '2019-08-16' Group By product_id) t2 on t1.product_id = t2.product_id and change_date = last_date ) Select b.product_id, CASE WHEN new_price is null then 10 else new_price End as price From a Right Join (Select distinct product_id From Products) b on a.product_id = b.product_id
With temp AS ( SELECT product_id, new_price, RANK() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS 'price_rank' FROM Products WHERE change_date <= '2019-08-16' ) SELECT DISTINCT t1.product_id, (CASE WHEN t2.product_id IS NULL THEN 10 ELSE t2.new_price END) AS price FROM Products t1 LEFT JOIN (SELECT * FROM temp WHERE price_rank = 1) t2 ON t1.product_id = t2.product_id
select DISTINCT pr.product_id,COALESCE(a.price,10) as price from Products pr left outer join ( select product_id, COALESCE(new_price,10) as price, DENSE_RANK() OVER(partition by product_id order by change_date desc) as rnk from Products where change_date <= '2019-08-16' )a on pr.product_id = a.product_id and a.rnk = 1
select TL.product_id, ifnull(new_price,10) as Price from (select distinct (product_id) as product_id from Products) as TL Left join (select * from (select product_id, new_price, rank() over (partition by product_id order by change_date desc) as ranking from Products where change_date <='2019-08-16') as t where ranking=1) as TR on TL.product_id=TR.product_id
select a.product_id, coalesce(new_price,10) as price from ( select product_id from products group by product_id )a left join ( select * from( select product_id, new_price, rank() over(partition by product_id order by change_date desc ) as rnk from products where change_date <= '2019-08-16' )b where rnk = 1 )c on a.product_id = c.product_id
select b.product_id, ifnull(c.new_price,10) as price from (select distinct product_id from products) b left join (select a.product_id, a.new_price from (select *, rank() over (partition by product_id order by change_date DESC) as price_rank from products where change_date<='2019-08-16') a where a.price_rank=1) c on b.product_id=c.product_id
select c.product_id, c.price from (select a.product_id, (case when b.rn =1 then b.new_price when b.rn is null then 10 else null end) as price from (select distinct(product_id) from products) a left join (select *, row_number() over( partition by product_id order by change_date desc) as rn from products where change_date <= '2019-08-16') b on a.product_id = b.product_id)c where c.price is not null
select c.product_id, coalesce(a.new_price,10) as price from products as a inner join (select product_id, max(change_date) as max_change_date from products where change_date <= '2019-08-16' group by product_id) as b on a.product_id=b.product_id and a.change_date=b.max_change_date right join (select distinct product_id from products) as c on a.product_id=c.product_id
select c.product_id, ifnull(d.new_price,10) as price from (select distinct product_id from products group by 1) as c left join (select a.product_id, a.new_price from products a right join (select product_id, max(change_date) as change_date from products where change_date <= '2019-08-16' group by 1) as b on a.product_id = b.product_id and a.change_date = b.change_date) as d on c.product_id = d.product_id
select c.product_id, ifnull(d.price, 10) price from (select distinct product_id from Products) c left join ( select a.product_id, a.new_price price from Products a join ( select product_id, max(change_date) latest_change_date from Products where change_date <= "2019-08-16" group by product_id ) b on a.product_id = b.product_id and a.change_date = b.latest_change_date) d on c.product_id = d.product_id
select d.product_id, (case when d.new_price is not null then d.new_price else 10 end) as price from (select distinct c.product_id, b.new_price, b.change_date from products c left join ((select a.product_id, a.new_price, a.change_date from (select *, max(change_date) over (partition by product_id) as max_dt from products where product_id not in (select product_id from products where change_date='2019-08-16') and change_date<'2019-08-16')a where a.change_date=a.max_dt) union all (select * from products where change_date='2019-08-16' )) b on c.product_id=b.product_id) d order by d.product_id
select d.product_id, if(isnull(c.new_price),10,c.new_price) price from (select product_id, new_price, max(change_date) as latest_change from Products where change_date <= '2019-08-16' group by product_id) b join (select product_id, new_price, change_date from Products) c on c.change_date = b.latest_change and c.product_id = b.product_id right outer join (select distinct product_id from Products) d on c.product_id = d.product_id
select def.product_id, ifnull(p1.new_price, 10) as price from ( select product_id, max(change_date) as m_date from Products where change_date <= '2019-08-16' group by 1 ) p2 join Products as p1 on p1.product_id = p2.product_id and p1.change_date = p2.m_date right join ( select distinct product_id, 10 as def_price from Products ) as def on def.product_id = p2.product_id
select distinct P.product_id, IFNULL(T1.new_price,10) as price from Products P left join (SELECT product_id, change_date, new_price, rank() OVER(PARTITION BY product_id ORDER BY change_date DESC) rnk from Products WHERE change_date<='2019-08-16')T1 on P.product_id = T1.product_id and T1.rnk =1 order by IFNULL(T1.new_price,10) desc
select distinct P.product_id, ifnull(tbl.new_price, 10) as price from Products P left join (select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rank_date from Products where datediff('2019-08-16', change_date) >=0) tbl on P.product_id = tbl.product_id where tbl.rank_date = 1 or tbl.rank_date is null order by 1
select distinct Products.product_id, ifnull(t1.new_price, 10) as price from Products left join (select * from Products where (product_id, change_date) in (select product_id, max(change_date) as change_date from Products where change_date <= '2019-08-16' group by product_id)) as t1 on Products.product_id = t1.product_id
select distinct T1.product_id, ifnull(t2.new_price,10) as price from products t1 left join (SELECT product_id, new_price FROM Products WHERE (product_id, change_date) IN (SELECT product_id, MAX(change_date) AS last_date FROM Products WHERE change_date <= '2019-08-16' GROUP BY product_id)) as T2 on t1.product_id=t2.product_id
select distinct a.product_id, coalesce(b.new_price, 10) as price from Products a left join (select product_id, rank() over(partition by product_id order by change_date desc) as xrank, new_price from Products where change_date <= '2019-08-16') as b on a.product_id = b.product_id and b.xrank = 1 order by 2 desc
select distinct a.product_id, coalesce(b.new_price, 10) as price from Products as a left join (select product_id, rank() over(partition by product_id order by change_date DESC) as xrank, new_price from Products where change_date<='2019-08-16') as b on a.product_id=b.product_id and b.xrank=1 order by 2 DESC
select distinct a.product_id, coalesce(b.new_price,10) as price from products a left join ( with resultcte as ( select product_id, new_price, dense_rank () over (partition by product_id order by change_date desc) as drank from products where change_date <= '2019-08-16' ) select product_id, new_price from resultcte where drank = 1 ) b on a.product_id = b.product_id
select distinct a.product_id, coalesce(price, 10) as price from products a left join ( select product_id, price from ( select product_id , new_price as price , rank() over (partition by product_id order by change_date desc) as date_rank from products where change_date <= '2019-08-16' ) a where date_rank = 1 ) b on a.product_id = b.product_id
select distinct a.product_id, coalesce(t.new_price,10) as price from Products a left join (select * from Products where (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16' group by 1))t on a.product_id = t.product_id
select distinct a.product_id, ifnull(b.new_price, 10) as price from Products a left join ( select * from Products where (product_id,change_date) in (select product_id, max(change_date) from Products where change_date <= "2019-08-16" group by product_id)) as b on a.product_id = b.product_id
select distinct a.product_id, ifnull(b.new_price, 10) as price from Products as a left join (select product_id, rank() over(partition by product_id order by change_date DESC) as xrank, new_price from Products where change_date<='2019-08-16') as b on a.product_id=b.product_id and b.xrank=1
select distinct a.product_id, ifnull(temp.new_price, 10) as price from products a left join (select * from products where (product_id, change_date) in (select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id)) as temp on a.product_id = temp.product_id
select distinct a.product_id, ifnull(temp.new_price, 10) as price from products as a left join ( select * from products where (product_id, change_date) in ( select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id ) ) as temp on a.product_id = temp.product_id
select distinct c.product_id, ifnull(d.new_price,10) as price from Products c left join (select * from Products where (product_id, change_date) in (select product_id, max(change_date) as max_date from Products where change_date <= '2019-08-16' group by product_id) ) d on c.product_id = d.product_id
select distinct p.product_id , IFNULL(ranked.new_price, 10) as price from products p left join ( select product_id, new_price, dense_rank() over (partition by product_id order by change_date desc) as ranks from products where change_date < '2019-08-17' ) ranked on p.product_id = ranked.product_id and ranks = 1 group by 1
select distinct p.product_id , coalesce(a.price,10) as price from products p left join (select distinct product_id as product_id , new_price as price from products where (product_id, change_date) in (select product_id, max(change_date) as change_date from products where change_date <= '2019-08-16' group by product_id)) as a on p.product_id = a.product_id
select distinct p.product_id, (case when temp.recent_price is null then 10 else recent_price end) as price from Products p left join (select *, first_value(new_price)over(partition by product_id order by change_date desc) as recent_price from Products where change_date <= '2019-08-16') temp on p.product_id = temp.product_id
select distinct p.product_id, coalesce(b.price,10) as price from products p left join ( select product_id,price from ( select product_id,new_price as price,dense_rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16') as a where rnk = 1) as b on b.product_id = p.product_id
select distinct p.product_id, coalesce(fin.new_price,10) as price from products p left join (select product_id,new_price, dense_rank() over (partition by product_id order by change_date desc) rnk from products where change_date <='2019-08-16') fin on p.product_id = fin.product_id and fin.rnk = 1
select distinct p.product_id, coalesce(price,10) as price from (select product_id,price from (select product_id, new_price as price, dense_rank() over (partition by product_id order by change_date desc) as rn from products where change_date <= "2019-08-16") as t where rn = 1) as t right join products p on t.product_id = p.product_id order by price desc
select distinct p.product_id, if(b.rnk = 1, b.nprice, 10) as price from products p left join (select product_id, new_price as nprice, rnk from (select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16')b where rnk = 1)b on p.product_id = b.product_id
select distinct p.product_id, ifnull(a.new_price,10) as price from Products p left join ( select product_id, new_price from products where (product_id, change_date) in (select product_id, max(change_date) as lst from products where change_date <= "2019-08-16" group by product_id) ) a on a.product_id = p.product_id
select distinct p.product_id, ifnull(b.new_price,10) as 'price' from products p left join (select product_id, new_price from ( select product_id, new_price, dense_rank() over(partition by product_id order by change_date desc) as 'rk' from products where change_date <= '2019-08-16') as A where rk = 1) as B on p.product_id = b.product_id
select distinct p.product_id, ifnull(c.new_price,10) as price from Products p left join ( (select p1.product_id, p1.new_price, p1.change_date from Products p1 where (p1.product_id, p1.change_date) in (select product_id, max(change_date) as max_date from Products where change_date <= '2019-08-16' group by product_id)) ) c on c.product_id = p.product_id
select distinct p.product_id, ifnull(k.new_price, 10) as price from Products p left join (select * from Products where (product_id, change_date) IN (select product_id, MAX(change_date) as change_date from Products where change_date <='2019-08-16' group by 1)) k ON p.product_id=k.product_id
select distinct p.product_id, ifnull(price, 10) as price from Products p left join (select product_id, new_price as price from Products where (product_id, change_date) in (select product_id, max(change_date) as cdt from Products where change_date <= '2019-08-16' group by product_id)) as temp on p.product_id = temp.product_id
select distinct p.product_id, ifnull(price,10) price from Products p left join (select product_id, new_price price, rank() over(partition by product_id order by change_date desc) ranked from Products where change_date <= '2019-08-16') temp on p.product_id = temp.product_id and ranked=1
select distinct p.product_id, ifnull(sub2.new_price, 10) as price from Products p left join ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from Products where change_date < '2019-08-17') sub2 on p.product_id = sub2.product_id where rnk=1 or rnk is null
select distinct p.product_id, ifnull(temp.new_price, 10) as price from (select *, rank() over(partition by product_id order by change_date desc)rnk from Products where change_date <= '2019-08-16')temp right join Products p on p.product_id = temp.product_id and rnk = 1
select distinct p.product_id, ifnull(temp.new_price,10) as price from Products p left join ( select * from Products ps where (ps.product_id, ps.change_date) in ( select pss.product_id, max(pss.change_date) from Products as pss where pss.change_date <= "2019-08-16" group by pss.product_id )) as temp on p.product_id = temp.product_id
select distinct p.product_id, ifnull(temp.new_price,10) price from Products p left join (select *, rank() over(partition by product_id order by change_date desc) rnk from Products where change_date <= '2019-08-16') temp on p.product_id = temp.product_id and rnk = 1
select distinct p.product_id, ifnull(temp.new_price,10) price from products p left join (select * from products where (product_id, change_date) in (select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id)) temp on p.product_id = temp.product_id
select distinct p.product_id, ifnull(tt1.new_price, 10) as price from Products p left join (select product_id, new_price from Products where (product_id, change_date) in (select product_id, max(change_date) as ddate from Products where change_date<= '2019-08-16' group by product_id)) tt1 on p.product_id = tt1.product_id
select distinct p.product_id,ifnull(price,10) as price from products p left join( select product_id,new_price as price from products where (product_id,change_date) IN(select product_id,max(change_date)from products where change_date<='2019-08-16' group by product_id))a on p.product_id=a.product_id
select distinct p.product_id,ifnull(temp.new_price,10) as price from products p left join (select product_id,new_price from products where (product_id,change_date) in (select product_id,max(change_date) from products where change_date<='2019-08-16' group by product_id)) temp on p.product_id=temp.product_id
select distinct p0.product_id, case when p3.new_price is not null then p3.new_price else 10 end as price from products p0 left join (select p1.product_id, p1.new_price, p1.change_date from products p1 where (product_id, change_date) in (select product_id, max(change_date) as last_date from Products where change_date <'2019-08-17' group by product_id) ) p3 on p0.product_id=p3.product_id
select distinct p1.product_id, case when p2.max_date is null then 10 else p1.new_price end as price from Products p1 left join( select product_id, max(change_date) as max_date from Products where change_date <= '2019-08-16' group by product_id ) p2 on p1.product_id = p2.product_id where p1.change_date = p2.max_date or p2.max_date is null
select distinct p1.product_id, ifnull(p2.new_price,10) as price from products p1 left join (select product_id,new_price,rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16') as p2 on p1.product_id = p2.product_id and p2.rnk = 1
select distinct p1.product_id, ifnull(temp.new_price, 10) price from products p1 left join ( select p.*, case when change_date = max(change_date) over (partition by product_id) then null else 'no' end marker from products p where change_date <= '2019-08-16') temp on p1.product_id = temp.product_id where temp.marker is null
select distinct p2.product_id, coalesce(t.price,10) as price from products p2 left join (select p1.product_id as product_id, p1.new_price as price, dense_rank() over (partition by p1.product_id order by p1.change_date desc) as cnt from products p1 where p1.change_date<='2019-08-16') t on p2.product_id=t.product_id and t.cnt=1
select distinct p2.product_id, ifnull(new_price,10) as price from (select product_id, new_price from products where (product_id,change_date) in (select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id)) p1 right join (select product_id from products) p2 on p1.product_id = p2.product_id
select distinct product_id , new_price as price from products where (product_id, change_date) in (select product_id, max(change_date) as change_date from products where change_date <= '2019-08-16' group by product_id) union select distinct product_id, 10 as price from Products group by product_id having min(change_date) > '2019-08-16'
select distinct product_id, 10 as price from Products group by product_id having (min(change_date) > "2019-08-16") union select p2.product_id, new_price from Products p2 where (p2.product_id, p2.change_date) in ( select product_id, max(change_date) as recent_date from Products where change_date <= "2019-08-16" group by product_id )
select distinct product_id, 10 as price from Products group by product_id having (min(change_date) > "2019-08-16") union select product_id, ifnull(new_price, 10) from Products inner join (select product_id, max(change_date) as change_date from Products where change_date <= '2019-08-16' group by product_id) as t1 using (product_id, change_date)
select distinct product_id, 10 as price from Products group by product_id having (min(change_date) > "2019-08-16") union select product_id, new_price from Products p2 where (product_id, change_date) in ( select product_id, max(change_date) from Products where change_date <= "2019-08-16" group by product_id )
select distinct product_id, 10 as price from Products group by product_id having min(change_date)>'2019-08-16' union select p2.product_id, new_price as price from Products p2 where (p2.product_id, p2.change_date) in ( select product_id, max(change_date) as recent_date from Products where change_date <= "2019-08-16" group by product_id )
select distinct product_id, 10 price from Products where product_id not in ( select t1.product_id from Products as t1, (select product_id, max(change_date) as ms from Products where change_date <= '2019-08-16' group by product_id) as t2 where (t1.product_id, t1.change_date) = (t2.product_id, t2.ms) ) union ( select distinct t1.product_id, t1.new_price as price from Products as t1, (select product_id, max(change_date) as ms from Products where change_date <= '2019-08-16' group by product_id) as t2 where (t1.product_id, t1.change_date) = (t2.product_id, t2.ms))
select distinct product_id, first_value(new_price) over (partition by product_id order by change_date desc) as price from products where change_date<="2019-08-16" union all select distinct product_id, 10 from products group by product_id having min(change_date) > "2019-08-16"
select distinct product_id, new_price as price from( select product_id, new_price, change_date, max(change_date) over (partition by product_id) as max_date from Products where change_date <= '2019-08-16') as TMP where change_date = max_date union select distinct product_id, 10 as price from( select product_id, new_price, change_date, min(change_date) over (partition by product_id) as min_date from Products) as TMP where min_date > '2019-08-16'
select distinct products.product_id, coalesce(a.new_price,10) as price from Products left join (select * from products where (product_id,change_date) in (select product_id, max(change_date) from products where change_date<='2019-08-16' group by product_id)) a on products.product_id=a.product_id
select distinct t1.product_id, case when t2.new_price is not null then t2.new_price else 10 end as price from products t1 left outer join ( select * from ( select *, row_number() over (partition by product_id order by change_date desc) as date_rank from products where change_date <= date("2019-08-16") ) inner_t where inner_t.date_rank = 1 ) t2 on t2.product_id = t1.product_id
select distinct t1.product_id, case when t4.product_id is null then 10 else t4.new_price end as price from products t1 left join ( select t2.product_id, t2.new_price from ( select t.product_id, t.new_price, row_number() over (partition by t.product_id order by t.change_date desc) as rk from products t where t.change_date<='2019-08-16' ) t2 where t2.rk=1 ) t4 on t1.product_id=t4.product_id
select distinct yy.product_id, ifnull(aa.new_price,10) as price from Products yy left join ( select product_id,new_price from ( select product_id,new_price, row_number() over (partition by product_id order by change_date desc) as rn from Products where change_date<'2019-08-17') as xx where xx.rn = 1) aa on yy.product_id = aa.product_id
select drv.product_id, (case when tmp.new_price is NULL then 10 else tmp.new_price end) as price from ( select distinct product_id from Products ) drv left join ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rk from Products where change_date <= '2019-08-16' ) tmp on drv.product_id = tmp.product_id and rk = 1
select p.product_id, case when n.product_id is null then 10 else n.new_price end as price from products as p left join (select product_id, new_price, row_number () over (partition by product_id order by change_date desc) as rnk from products where change_date<='2019-08-16') n on p.product_id=n.product_id and n.rnk=1 group by 1,2 order by 2 desc
select p.product_id, coalesce(new_price,10) as price from (select distinct product_id from products) p left join (select product_id, new_price from ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) ranking from ( select * from products where change_Date <='2019-08-16' ) A ) B where ranking=1 ) C on p.product_id=C.product_id
select p.product_id, if(t.lastday, t.new_price, 10) as price from (select distinct product_id from Products) as p left join ( select product_id, new_price, change_date, row_number() over (partition by product_id order by change_date desc) as lastday from Products where change_date <= '2019-08-16') as t on p.product_id = t.product_id where t.lastday = 1 or t.lastday is null
select p.product_id, ifnull(t.new_price, 10) price from products p left join ( select product_id, new_price from products where (product_id, change_date) in ( select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id ) ) t on p.product_id = t.product_id group by p.product_id
select p.product_id, ifnull(temp.new_price, 10) as price from Products p left join (SELECT product_id, new_price, rank() over(partition by product_id order by change_date desc) as price_rank from Products where change_date <= '2019-08-16') temp on temp.product_id = p.product_id and temp.price_rank = 1 group by p.product_id
select p.product_id, new_price as price from products p where (product_id, change_date) in (select product_id, max(change_date) as change_date from products where change_date <='2019-08-16' group by product_id) union (select product_id,10 as price from products group by product_id having min(change_date)>'2019-08-16')
select p.product_id, p.new_price as price from products p left join ( select product_id, MAX(change_date) as last_change_date from products where change_date <= '2019-08-16' group by product_id ) as last_changed_prices on p.product_id = last_changed_prices.product_id where p.change_date = last_changed_prices.last_change_date union all select p.product_id, 10 as price from products p left join ( select product_id, MAX(change_date) as last_change_date from products group by product_id having min(change_date) > '2019-08-16' ) as last_changed_prices on p.product_id = last_changed_prices.product_id where p.change_date = last_changed_prices.last_change_date
select p1.product_id, 10 as price from Products p1 group by p1.product_id having min(p1.change_date) > '2019-08-16' union select p2.product_id, p2.new_price as price from Products as p2 where (p2.product_id, p2.change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16'group by product_id )
select p1.product_id, case when p2.new_price is null then 10 else p2.new_price end as price from (select distinct product_id from Products) p1 left join (select p3.product_id, p3.new_price from (select product_id, new_price, row_number() over (partition by product_id order by change_date desc) as ranks from Products where change_date <= '2019-08-16') p3 where p3.ranks = 1 ) p2 on p1.product_id = p2.product_id
select p1.product_id, case when p2.new_price is null then 10 else p2.new_price end as price from (select distinct product_id from Products) p1 left join (select p4.product_id, p3.new_price from (select p.product_id, max(p.change_date) as change_date from Products p where p.change_date <= '2019-08-16' group by p.product_id) p4 inner join Products p3 on p3.product_id = p4.product_id and p3.change_date = p4.change_date ) p2 on p1.product_id = p2.product_id
select p1.product_id, case when p3.new_price is null then 10 else p3.new_price end as "price" from Products as p1 left join ( select * from ( select product_id,new_price, rank() over (partition by product_id order by change_date desc) as rnk from Products where change_date<='2019-08-16' ) as p2 where p2.rnk=1 )p3 on p1.product_id=p3.product_id group by 1,2 order by 2
select p1.product_id, p1.new_price as price from Products p1 where p1.change_date <= '2019-08-16' and (product_id, datediff('2019-08-16', p1.change_date)) in (select product_id, min(datediff('2019-08-16', change_date)) from Products where change_date <= '2019-08-16' group by product_id) union select product_id, 10 as price from Products group by product_id having min(change_date) > '2019-08-16' order by price desc
select p2.product_id, IFNULL(p1.price, 10) as price from (select product_id, new_price as price from (select product_id, new_price, row_number() over (partition by product_id order by change_date desc ) as ranks from Products where change_date <= '2019-08-16') as t where ranks = 1) p1 right join (select distinct product_id from Products) p2 on p1.product_id = p2.product_id
select p2.product_id, ifnull(p1.price, 10) as price from (select distinct product_id from products) as p2 left join ( select product_id, new_price as price from products p where (product_id,change_date) in (select product_id, max(change_date) from products where change_date<='2019-08-16' group by product_id) ) as p1 on p2.product_id = p1.product_id
select pid.product_id, (CASE WHEN xyz.product_id is NULL then 10 ELSE xyz.new_price END) 'price' from (select distinct product_id from products) pid left join (select product_id, new_price from (select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) 'rnk' from products where change_date <='2019-08-16') abc where rnk = 1) xyz on pid.product_id = xyz.product_id order by 2 desc
select product_id , 10 as price from Products group by product_id having min(change_date)>'2019-08-16' union select t.product_id , t.new_price as price from (select *,dense_rank() over (partition by product_id order by change_date desc) as rnk from Products where change_date <='2019-08-16')t where t.rnk=1
select product_id , 10 as price from products where product_id not in (select product_id from products where change_date <= '2019-08-16') union select product_id , new_price as price from products where (product_id , change_date) in (select product_id , max(change_date) as change_date from products where change_date <= '2019-08-16' group by product_id)
select product_id , new_price as price from (select product_id , new_price , dense_rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16') a where rnk = 1 union select distinct product_id , 10 as price from products where product_id not in (select distinct product_id from products where change_date <= '2019-08-16')
select product_id , price from ( select * from ( select product_id , new_price as price , rank() over (partition by product_id order by change_date desc) as date_rank from products where change_date <= '2019-08-16' ) a where date_rank = 1 ) b union select product_id , 10 as price from products where product_id not in (select distinct product_id from products where change_date <= '2019-08-16')
select product_id, 10 as 'price' from products group by product_id having min(change_date) > '2019-08-16' union all select product_id, new_price as 'price' from products where (product_id, change_date) in (select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id) order by product_id
select product_id, 10 as price from Products group by 1 having min(change_date) > '2019-08-16' union select product_id, new_price as price from Products where (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16' group by 1)
select product_id, 10 as price from products group by 1 having min(change_date) > '2019-08-16' union select product_id, new_price from products where (product_id, change_date) in ( select product_id, max(change_date) from products where change_date <= '2019-08-16' group by 1 )
select product_id, 10 as price from products group by 1 having min(change_date)>'2019-08-16' union select product_id, new_price as price from products where (product_id,change_date)in (select product_id, max(change_date) from products where change_date<='2019-08-16' group by 1)
select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16' UNION select product_id, new_price as price from products where (product_id,change_date) IN (select Product_id,max(change_date) from products where change_date < '2019-08-17' group by product_id)
select product_id, Price from (select Product_ID, new_price as Price, Rank () over (partition by product_id order by change_date desc ) as rnk from Products where change_date <= '2019-08-16') temp where rnk =1 Union Select Product_id,10 from Products where product_id not in (select product_id from Products where change_date <= '2019-08-16')
select product_id, case when change_date > '2019-08-16' then 10 else new_price end as price from ( select product_id, new_price, change_date, row_number() over( partition by product_id order by (case when change_date > '2019-08-16' then 0 else change_date end) desc) as dt_rank from Products ) as a where dt_rank =1
select product_id, max(case when p_id is null then 10 else new_price end) as price from Products P left join ( select distinct product_id as p_id, max(change_date) over (partition by product_id) as final_update from Products where change_date <= '2019-08-16' ) latest_update_date on product_id = p_id and final_update = change_date group by product_id
select product_id, new_price as price from ( select *, row_number() over (partition by product_id order by change_date desc) as latest from Products where change_date <= '2019-08-16') new where new.latest=1 union select product_id, 10 as price from Products group by product_id having min(change_date) > '2019-08-16'
select product_id, new_price as price from ( select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) as change_rank from products where change_date<='2019-08-16') sub where change_rank = 1 union select product_id, 10 as price from( select product_id, min(change_date) as min_date from products group by product_id ) sub_2 where min_date > '2019-08-16'
select product_id, new_price as price from Products where change_date<="2019-08-16" and (product_id, datediff("2019-08-16",change_date)) in (select product_id, min(datediff("2019-08-16",change_date)) from Products where change_date<="2019-08-16" group by product_id) union select product_id, 10 as price from Products group by product_id having min(change_date)>"2019-08-16" order by price desc
select product_id, new_price as price from products p where change_date <= '2019-08-16' and change_date >= all( select change_date from products where change_date <= '2019-08-16' and product_id = p.product_id ) union select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16'
select product_id, new_price as price from products where (product_id, change_date) in ( select product_id, max(change_date) as max_date from products where change_date <= '2019-08-16' group by product_id ) union select product_id, 10 as price from products where product_id not in ( select product_id from products where change_date <= '2019-08-16' )
select product_id, new_price as price from products where (product_id, change_date) in (select product_id, max(change_date) change_date from products where change_date <= '2019-08-16' group by 1) union select product_id, 10 as price from products group by 1 having min(change_date) > '2019-08-16'
select product_id, new_price price from Products where (product_id, change_date) in ( select product_id, max(change_date) as max_date from products where change_date <= '2019-08-16' group by product_id) union select product_id, 10 price from Products where product_id not in (select product_id from Products where change_date <= '2019-08-16')
select product_id, price from (select product_id, new_price as price, rank() over (partition by product_id order by change_date desc) rnk_price from Products where change_date <= '2019-08-16') as rnked where rnk_price = 1 union select product_id, 10 as price from Products group by product_id having (min(change_date) > "2019-08-16")
select product_id, price from (select product_id,new_price price, rank() over (partition by product_id order by change_date desc) rk from products where change_date<='2019-08-16')f where f.rk=1 union select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16'
select product_id,new_price as price FROM Products WHERE (product_id,change_date) IN (select product_id,max(change_date) from products where change_date<= "2019-08-16" group by product_id) UNION SELECT product_id,10 as price FROM Products GROUP BY product_id HAVING min(change_date)> "2019-08-16"
select product_id,new_price as price from (select product_id,rank() over ( partition by product_id order by change_date desc)as rn,new_price from Products where change_date <= '2019-08-16')t1 where rn = 1 union select product_id,10 as price from Products where product_id not in ( select product_id from Products where change_date <= '2019-08-16' )
select product_id,new_price as price from Products where (product_id,change_date) in ( select product_id,max(change_date) from products where change_date<= '2019-08-16' group by product_id ) union select product_id,10 as price from Products group by product_id having(min(change_date ))> '2019-08-16' order by product_id
select t1.product_id as product_id, if(isnull(t2.price), 10, t2.price) as price from (select distinct product_id from Products) as t1 left join (select product_id, new_price as price from Products where (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16' group by product_id)) as t2 on t1.product_id = t2.product_id
select t1.product_id as product_id, if(isnull(t2.price), 10, t2.price) as price from (select distinct product_id from Products) as t1 left join (select product_id, new_price as price from Products where (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <='2019-08-16' group by product_id)) as t2 on t1.product_id = t2.product_id
select t1.product_id, coalesce(t2.price,10) as price from ( select product_id from products group by product_id ) t1 left join ( select distinct product_id, first_value(new_price) over (partition by product_id order by change_date desc) as price from products where change_date <= '2019-08-16' ) t2 on t1.product_id = t2.product_id
select t1.product_id, coalesce(t2.price,10) as price from ( select product_id from products group by product_id ) t1 left join ( select product_id, new_price as price from ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rk from products where change_date <= '2019-08-16' ) tmp where rk = 1) t2 on t1.product_id = t2.product_id
select t1.product_id, ifnull(t2.new_price, 10) as price from (select distinct product_id from products) t1 left join (select product_id, new_price from products where (product_id, change_date) in (select product_id, max(change_date) from products where change_date <= '2019-08-16' group by product_id) ) t2 on t1.product_id = t2.product_id
select t1.product_id, ifnull(t2.new_price,10) as price from (select distinct product_id from Products) as t1 left join (select product_id, new_price from Products where (product_id,change_date) in (select product_id,max(change_date) from Products where change_date <="2019-08-16" group by product_id)) as t2 on t1.product_id=t2.product_id
select t1.product_id, t1.new_price as price from products t1 where (t1.product_id, t1.change_date) in ( select product_id, max(change_date) as max_date from products where change_date <= date("2019-08-16") group by product_id ) union select distinct t2.product_id, 10 as price from products t2 group by t2.product_id having min(t2.change_date) > date("2019-08-16")
select t2.product_id, ifnull(p.new_price, 10) as price from ( select product_id, max(change_date) as max_date from products where change_date <= '2019-08-16' group by product_id ) t1 join products p on t1.product_id = p.product_id and t1.max_date = p.change_date right join (select distinct product_id from products) t2 on p.product_id = t2.product_id
select t2.product_id, ifnull(p.new_price, 10) price from products p join ( select product_id, max(change_date) last_date from products where change_date <= '2019-08-16' group by product_id ) t1 on p.product_id = t1.product_id and p.change_date = t1.last_date right join ( select distinct product_id from products ) t2 on p.product_id = t2.product_id
with CTE as ( Select product_id, new_price, DENSE_RANK() over (partition by product_id order by change_date DESC) as rk from Products where change_date <= '2019-08-16' ) Select product_id, new_price as price from CTE where rk = 1 UNION Select product_id, 10 as price from Products where product_id not in (Select DISTINCT product_id from CTE)
with CTE as ( select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) as pricing_order from products where change_date<='2019-08-16' ), CTE2 as( select distinct product_id from products ) select cte2.product_id, ifnull(cte.new_price,10) as price from cte2 left join cte on cte.product_id=cte2.product_id and pricing_order=1
with G as (select P.product_id "product_id", max(P.change_date) as MD from Products P where change_date <= '2019-08-16' group by product_id) select F.product_id, max(F.Price) Price from (select P2.product_id, if ((P2.change_date = G.MD and P2.product_id = G.product_id), P2.new_price, 10) as Price from Products P2, G) as F group by F.product_id
with a as ( select product_id , max(change_date) change_date from products where change_date <= '2019-08-16' group by product_id ) select p.product_id, new_price as price from Products p join a on p.product_id=a.product_id and p.change_date=a.change_date union select p.product_id, 10 as price from Products p where p.product_id not in (select product_id from a)
with a as ( select product_id, new_price from ( select product_id, new_price, row_number() over (partition by product_id order by change_date desc) as row_num from Products where change_date <= '2019-08-16' )ab where row_num =1 ) select distinct b.product_id, coalesce(a.new_price, 10) as price from Products b left join a on b.product_id = a.product_id
with a as ( select product_id, new_price from products where change_date = '2019-08-16' ), b as ( select product_id, new_price, row_number() over(partition by product_id order by change_date desc) pos from products where change_date < '2019-08-16' and product_id not in (select product_id from a) ), c as ( select product_id, new_price as price from products where product_id not in (select product_id from b) and product_id not in (select product_id from a) ) select product_id, new_price as price from b where pos = 1 union select product_id, new_price as price from a union select product_id, 10 as price from c
with a as ( select product_id, new_price, change_date from Products where change_date <= '2019-08-16' ), b as ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from a ), c as ( select product_id, new_price from b where rnk = 1 ) select distinct p.product_id, ifnull(c.new_price, 10) as price from Products p left join c on c.product_id = p.product_id
with a as (select distinct product_id from Products), b as (select product_id,new_price, rank() over (partition by product_id order by change_date desc) rank_no from Products where change_date<='2019-08-16') select a.product_id,coalesce(new_price,10) as price from a left join b on a.product_id=b.product_id and rank_no=1
with a as (select distinct product_id, first_value(new_price) over (partition by product_id order by change_date desc) as price from products where change_date<="2019-08-16") select * from a union all select distinct product_id, 10 from products where product_id not in (select product_id from a)
with a as( select *, rank() over(partition by product_id order by change_date desc) as r from Products where change_date <= '2019-08-16') select product_id, 10 as price from Products where product_id not in (select product_id from a) union select product_id, new_price as price from a where r = 1 order by product_id
with a as( select *, row_number() over (partition by product_id order by change_date desc) as rk from( select * , count(product_id) over (partition by product_id) as num_changes from products) as temp where change_date <= date '2019-08-16' or num_changes=1 ), b as ( select product_id, 10 from( select * , if(change_date <= date '2019-08-16', 1, 0) as in_range from products) as temp group by product_id having sum(in_range)=0 ) select product_id , case when change_date <= date '2019-08-16' then new_price else 10 end as price from a where rk=1 union select * from b
with a as( select *, row_number()over(partition by product_id order by change_date desc)as rk from products where change_date<='2019-08-16') select distinct product_id, new_price as price from a where rk=1 union select distinct product_id, 10 as price from products where product_id not in ( select product_id from a)
with all_products as ( Select distinct product_id as product_id from Products ), product_info as ( Select ap.product_id, coalesce(new_price, 10) as price, coalesce (change_date, '2019-01-01') change_date from all_products ap left outer join Products p on ap.product_id = p.product_id and change_date <= '2019-08-16' ), product_rank as ( Select product_id, price, rank() over (partition by product_id order by change_date desc) as rnk From product_info ) Select product_id, price From product_rank where rnk = 1
with augmented as ( select * from Products union all select product_id, 10 as new_price, date('1900-01-01') as change_date from Products group by product_id ), temp as ( select product_id, new_price, row_number() over (partition by product_id order by change_date DESC) as rk from augmented where change_date <= '2019=08-16' ) select product_id, new_price as price from temp where rk = 1
with b as (select distinct product_id from products), a as (select product_id, new_price, change_date, dense_rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019_08-16') select product_id, (case when new_price is null then 10 else new_price end) as price from (select b.product_id, new_price from b left join a on b.product_id =a.product_id and rnk=1)c
with before_cutoff as ( select product_id, price from (select product_id, new_price as price, rank() over (partition by product_id order by change_date desc) rnk_price from Products where change_date <= '2019-08-16') as rnked where rnk_price = 1 ) select all_id.product_id, coalesce(price,10) as price from (select distinct product_id from Products) as all_id left join before_cutoff as bc on all_id.product_id = bc.product_id
with c as ( select product_id , new_price, last_value(new_price) over (partition by product_id ORDER BY change_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as lprice from Products where change_date <= '2019-08-16' order by change_date ) select distinct p.product_id, coalesce(lprice,10) as price from (select distinct product_id from Products ) p left join c on p.product_id = c.product_id
with c as( select distinct product_id from products), b as( select product_id, max(change_date) as date_ from products where change_date<='2019-08-16' group by 1), a as( select p.product_id, p.new_price from products p join b on p.product_id=b.product_id and p.change_date=b.date_) select c.product_id, ifnull(a.new_price,10) as price from c left join a on c.product_id=a.product_id
with changed_product as ( select product_id, new_price from (select product_id, new_price, rank() over (partition by product_id order by change_date DESC) as rk from Products where change_date < '2019-08-17') as t where t.rk = 1 ), product_list as ( select distinct product_id from Products ) select p.product_id, ifnull(c.new_price,10) as price from product_list p left join changed_product c on p.product_id = c.product_id
with combined as ( select distinct product_id, 10 as price, '1900-01-01' as dt from products union all select product_id, new_price as price, change_date as dt from products where change_date <= '2019-08-16' ), temp as( select *, row_number() over(partition by product_id order by dt desc) as rk from combined ) select product_id, price from temp where rk = 1
with consolidated as ( with final as ( with ordered as ( Select * ,max(change_date) over(partition by product_id) as 'latest_occurence', min(change_date) over (partition by product_id) as'first_occurence', count(product_id) over(partition by product_id) as 'cnt' from Products order by product_id,change_date ) Select product_id,max(change_date)as 'dum_date' from ordered where change_date <= "2019-08-16" group by product_id ) Select f.product_id,p.new_price as 'price' from final f inner join products p on f.product_id = p.product_id and f.dum_date = p.change_date union Select a.product_id,a.price from ( with ordered as ( Select * ,max(change_date) over(partition by product_id) as 'latest_occurence', min(change_date) over (partition by product_id) as'first_occurence', count(product_id) over(partition by product_id) as 'cnt' from Products order by product_id,change_date ) Select product_id , 10 as 'price' from ordered where first_occurence > "2019-08-16" )a ) Select * from consolidated order by product_id
with cte as ( select * from products where change_date<='2019-08-16' ), temp as ( select product_id,max(change_date) as change_date from cte group by product_id ), sub as ( select temp.product_id,p.new_price from temp join products as p on temp.product_id=p.product_id and temp.change_date=p.change_date ), demo as ( select distinct product_id from products ) select demo.product_id, coalesce(sub.new_price,10) as price from demo left join sub on demo.product_id=sub.product_id
with cte as ( select *, datediff(DATE('2019-08-16'), change_date) as dd from Products ) ( select product_id, new_price as price from ( select *, min(dd) over(partition by product_id) as dd_min from (select product_id, new_price, change_date, (case when dd < 0 then 999 else dd end) as dd from cte) as p1 ) as p2 where dd = dd_min and change_date <= DATE('2019-08-16') ) UNION ALL ( select distinct product_id, 10 as price from cte where product_id not in (select product_id from cte where change_date <= DATE('2019-08-16')) )
with cte as ( select *, rank() over (partition by product_id order by change_date desc) as rk from Products where change_date<= '2019-08-16' ), cte2 as ( select product_id, new_price as price from cte where rk = 1 ) select distinct p.product_id, ifnull(cte2.price,10) as price from Products p left join cte2 on p.product_id = cte2.product_id order by 2 desc
with cte as ( select a.product_id, a.new_price as latest_price from ( select product_id, new_price, ROW_NUMBER() over (partition by product_id order by change_date desc) as lat_price from Products p where change_date <= '2019-08-16' ) a where a.lat_price = 1 ) select distinct p.product_id, ifnull(a.latest_price, 10) as price from Products p left join cte a on p.product_id = a.product_id
with cte as ( select distinct product_id, 10 as new_price, '2019-01-01' as change_date from Products union select * from Products ) select product_id, price from( select product_id, new_price as price, row_number() over (partition by product_id order by change_date desc) as rnk from cte where change_date <= '2019-08-16')a where rnk = 1
with cte as ( select distinct product_id, 10 as original from products ), cte2 as ( select product_id, new_price from( select product_id, change_date, new_price, row_number() over (partition by product_id order by change_date desc) as rw from products where change_date <= '2019-08-16')a where a.rw=1 ) select distinct cte.product_id, ifnull(new_price, original) as price from cte left join cte2 on cte.product_id = cte2.product_id
with cte as ( select distinct product_id, first_value(new_price) over (partition by product_id order by change_date desc) as price from products where change_date<='2019-08-16' ) select product_id, 10 as price from products where product_id not in (select distinct product_id from cte) union select product_id, price from cte
with cte as ( select distinct product_id, first_value(new_price) over (partition by product_id order by change_date desc) from products where change_date <= '2019-08-16') select product_id, 10 as price from products where change_date > '2019-08-16' and product_id not in (select product_id from cte) group by product_id union all select * from cte order by product_id
with cte as ( select distinct product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) rn from products where change_date<='2019-08-16' ) select distinct p.product_id, coalesce(c.new_price,10) as price from products p left join cte c on (p.product_id = c.product_id and rn=1)
with cte as ( select distinct product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) rn from products where change_date<='2019-08-16' ) select distinct p.product_id, ifnull(c.new_price,10) as price from products p left join cte c on (p.product_id = c.product_id and rn=1)
with cte as ( select distinct product_id, new_price, rank () over (partition by product_id order by product_id, change_date desc) as rk from products where change_date <= '2019-08-16' ) select distinct a.product_id, case when cte.new_price is null then 10 else cte.new_price end as price from products a left join cte using (product_id) where rk = 1 or rk is null
with cte as ( select product_id ,max(change_date) as change_date2 from Products where change_date <='2019-08-16' group by 1 ) ,cte2 as ( select p.product_id ,p.new_price from Products p join cte c on p.product_id = c.product_id and p.change_date = c.change_date2 ) ,cte3 as ( select distinct product_id from Products ) select c3.product_id ,coalesce(c2.new_price,10) as price from cte3 c3 left join cte2 c2 on c3.product_id= c2.product_id
with cte as ( select product_id, first_value(new_price) over(partition by product_id order by change_date desc) as price from products where change_date <= '2019-08-16' ) select product_id, price from cte union select product_id, 10 from products where product_id not in (select product_id from cte)
with cte as ( select product_id, max(change_date) latest from products where change_date <= '2019-08-16' group by product_id) select p.product_id, new_price as price from products p join cte on p.product_id = cte.product_id and p.change_date = cte.latest union select product_id, 10 as price from products group by 1 having min(change_date) > '2019-08-16'
with cte as ( select product_id, max(change_date) latest from products where change_date <= '2019-08-16' group by product_id), cte2 as ( select p.product_id, p.new_price from products p join cte on p.product_id = cte.product_id and p.change_date = cte.latest) select p.product_id, case when cte2.product_id is null then 10 else cte2.new_price end as price from (select distinct product_id from products) p left join cte2 on p.product_id = cte2.product_id
with cte as ( select product_id, max(new_price) as price from ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16') b where rnk = 1 group by product_id) select product_id, 10 as price from products where change_date > '2019-08-16' and product_id not in (select product_id from cte) group by product_id union all select * from cte order by product_id
with cte as ( select product_id, max(p.change_date) as change_date from Products p where p.change_date <= '2019-08-16' group by product_id ) select distinct product_id, new_price as price from Products where (product_id, change_date) in (select product_id, change_date from cte) union select product_id, 10 as price from Products where (product_id) not in (select product_id from cte)
with cte as ( select product_id, new_price as price, change_date, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ) select product_id, price from cte where rnk = 1 union select product_id, 10 from products where product_id not in (select product_id from cte)
with cte as ( select product_id, new_price as price, row_number()over (partition by product_id order by change_date desc) as ranks from Products where change_date <= '2019-08-16' ) select p.product_id, case when c.price is null then 10 else c.price end as price from Products p left join cte c on p.product_id = c.product_id where c.ranks = 1 or c.ranks is null group by p.product_id,price order by c.price desc
with cte as ( select product_id, new_price, change_date, dense_rank() over (partition by product_id order by change_date desc) as rnk from Products p where change_date <= '2019-08-16' ), unique_prd as ( select distinct product_id from Products ) select p.product_id, coalesce(c.new_price, 10) as price from unique_prd p left join (select product_id, new_price, change_date from cte where rnk = 1) c on (p.product_id = c.product_id)
with cte as ( select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) rn from products where change_date<='2019-08-16' ) select distinct p.product_id, ifnull(c.new_price,10) as price from products p left join cte c on (p.product_id = c.product_id and rn=1)
with cte as ( select product_id, new_price, dense_rank() over (partition by product_id order by change_date desc) as rnk from Products where change_date <= "2019-08-16" ) select a.product_id, ifnull(b.new_price, 10) as price from (select distinct product_id from Products) a left join (select * from cte where rnk=1) b on a.product_id=b.product_id
with cte as ( select product_id, new_price, row_number() over(partition by product_id order by change_date desc) rn from products where change_date <= "2019-08-16" ) select distinct p.product_id, ifnull(c1.new_price, 10) as price from products p left join cte c1 on c1.product_id = p.product_id and c1.rn = 1
with cte as ( select product_id, price from ( select product_id, new_price price, rank() over(partition by product_id order by change_date desc) as rk from products where change_date <= '2019-08-16' ) a where rk = 1 ) select p.product_id, ifnull(pr.price, 10) as price from ( select distinct product_id from products ) p left join cte pr on p.product_id = pr.product_id
with cte as ( select product_id,max(change_date) max_change_date from products where change_date<='2019-08-16' group by product_id ) select a.product_id,ifnull(b.new_price,10) as price from (select distinct product_id from products) a left join products b on a.product_id=b.product_id and (b.product_id,b.change_date) in (select product_id,max_change_date from cte)
with cte as ( select product_id,new_price as price ,dense_rank()over(partition by product_id order by change_date desc) as rnk from products where change_date<='2019-08-16' ) select a.product_id, case when b.price is null then 10 else b.price end as price from (select distinct product_id from products) a left join (select * from cte where rnk=1) b on a.product_id=b.product_id
with cte as (select *, rank() over (partition by product_id order by change_date desc) as rn from products where change_date <= '2019-08-16') select distinct p.product_id, ifnull(tt.new_price, 10) as price from products p left join (select * from cte where rn = 1) tt on p.product_id = tt.product_id
with cte as (select *, rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16') select distinct a.product_id, case when b.new_price is null then 10 else b.new_price end as price from products a left join cte b on a.product_id = b.product_id and rnk = 1
with cte as (select distinct product_id from Products), cte2 as (select product_id, change_date, new_price from Products where (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16' group by product_id) ) select cte.product_id, (case when cte2.change_date is null then 10 else new_price end) as price from cte left join cte2 on cte.product_id = cte2.product_id
with cte as (select product_id, max(change_date) as change_date from Products where change_date <= date('2019-08-16') group by product_id), cte1 as (select p.product_id, p.new_price as price from products p join cte c on p.product_id = c.product_id and p.change_date = c.change_date) select distinct p.product_id, ifnull(c.price,p.price) as price from (select distinct product_id, 10 as price from products) as p left join cte1 c on p.product_id = c.product_id order by 2 desc
with cte as (select product_id, new_price as price from Products where change_date <= '2019-08-16' and (product_id, change_date) in (select product_id, max(change_date) from Products where change_date <= '2019-08-16' group by 1) order by 1) select * from cte union select product_id, 10 as price from Products where product_id not in (select product_id from cte)
with cte as (select product_id, new_price as price, rank() over(partition by product_id order by change_date desc) as rk from products where change_date <= '2019-08-16' ) select product_id, price from cte where rk = 1 union select product_id, 10 as price from products group by 1 having min(change_date) > '2019-08-16'
with cte as (select product_id, new_price, change_Date, rank() over (partition by product_id order by change_date desc) rnk from products where change_date <= '2019-08-16' ) select product_id, new_price as price from cte where rnk = 1 group by 1 union select product_id, 10 as price from products where change_date > '2019-08-16' and product_id not in (select product_id from cte)
with cte as (select product_id, new_price, change_date , first_value(new_price) over (partition by product_id order by change_date desc) as finalprice from Products where change_date<='20190816' ) select distinct product_id, case when (finalprice is null or finalprice= 10) then 10 else finalprice end as price from cte union all select distinct product_id, 10 as price from Products where product_id not in (select distinct product_id from Products where change_date <='20190816' )
with cte as (select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rn from products where change_date <= '2019-08-16'), cte2 as (select product_id, 10 from products where product_id not in (select product_id from cte where rn = 1)) select product_id, new_price as price from cte where rn = 1 union select product_id, 10 from cte2
with cte as (select product_id, new_price, rank() over(partition by product_id order by change_date desc) r from products where change_date <= '2019-08-16'), cte2 as (select product_id, new_price from cte where r = 1) select distinct p.product_id, ifnull(cte2.new_price,10) price from cte2 right join products p on cte2.product_id = p.product_id
with cte as (select product_id,new_price, rank() over( partition by product_id order by change_date desc) as r1 from products where change_date<=' 2019-08-16') ,cte2 as( select distinct product_id,new_price from cte where r1=1 ) select distinct p.product_id,ifnull(c.new_price,10) as price from products p left join cte2 c on p.product_id=c.product_id order by price desc
with cte as (select product_id,new_price,change_date from Products where change_date<='2019-08-16' order by change_date desc), cte2 as( select distinct product_id from Products ), cte3 as ( select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rnk from Products where change_date<='2019-08-16' ) select a.product_id, coalesce(b.new_price,10) as price from cte2 as a left join cte3 as b on a.product_id=b.product_id and b.rnk=1 group by a.product_id
with cte as (select product_id,new_price,change_date, max(change_date) over (partition by product_id) abc from products having change_date <= '2019-08-16') select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16' union select product_id, new_price price from cte where abc = change_date
with cte as( select product_id, change_date, new_price, rank() over(partition by product_id order by change_date desc) rk from products where change_date <= '2019-08-16') select distinct p.product_id, ifnull(t.new_price,10) as price from products p left join (select product_id as pid, new_price from cte where rk = 1) t on p.product_id = t.pid
with cte as( select product_id, max(change_date) as d from Products where change_date <= '2019-08-16' group by product_id) select p.product_id, p.new_price as price from Products p left join cte on p.change_date = cte.d and p.product_id = cte.product_id where cte.d is not null union select product_id, 10 price from Products where product_id not in (select product_id from cte) group by product_id
with cte as( select product_id, new_price as price, rank() over(partition by product_id order by change_date desc) as ranks from products where change_date <= '2019-08-16') select P.product_id, case when c.price is null then 10 else c.price end as price from products p left join cte c on p.product_id = c.product_id and ranks = 1 group by 1
with cte as( select product_id, new_price, change_date, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ) select distinct p.product_id, case when cte.new_price is null then 10 else cte.new_price end as price from products p left join cte on p.product_id = cte.product_id and cte.rnk=1
with cte as( select product_id, new_price, dense_rank()over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ) (select product_id, 10 as price from products where product_id not in (select product_id from cte)) union (select product_id, new_price from cte where rnk = 1)
with cte as( select product_id,new_price,change_date, row_number() over(partition by product_id order by change_date desc) as rnk from Products where change_date <= '2019-08-16') ,cte1 as( select product_id,10 as new_price,change_date, row_number() over(partition by product_id order by change_date desc) as rnk from Products where change_date > '2019-08-16' and product_id not in( select product_id from cte)) select product_id,price from( select distinct cte.product_id, cte.new_price as price from cte where cte.rnk = 1 union select distinct cte1.product_id, cte1.new_price as price from cte1 where cte1.rnk = 1) a order by 1
with cte as(select product_id, new_price, rank() over(partition by product_id order by change_date desc) myrank from products where change_date<='2019-08-16') select p.product_id, ifnull(c.new_price,10) as price from products p left join cte c on p.product_id=c.product_id and c.myrank=1 group by 1
with cte1 as ( Select *, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ), cte2 as ( select product_id, new_price from cte1 where rnk = 1 ) Select distinct p.product_id, ifnull(cte2.new_price, 10) as price from cte2 right join products p on cte2.product_id = p.product_id
with cte1 as ( Select product_id , new_price , row_number() over (partition by product_id order by change_date desc) as req from products where change_date <= '2019-08-16' ), cte2 as (Select product_id , new_price as price from cte1 where cte1.req = 1), cte3 as (select product_id, 10 as price from Products where product_id not in (select distinct product_id from cte2)) select product_id, price from cte2 union select product_id, price from cte3
with cte1 as ( select *, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date<='2019-08-16'), cte2 as ( select product_id, new_price as price from cte1 where rnk=1) select p.product_id, ifnull(c.price,10) as price from products p left join cte2 c on p.product_id=c.product_id group by 1,2
with cte1 as (select *,rank() over(partition by product_id order by change_date desc) rk from Products where change_date<='2019-08-16'), cte2 as (select distinct product_id,new_price from cte1 where rk=1) select distinct p.product_id,ifnull(cte2.new_price,10) as price from cte2 right join Products p using (product_id) order by price desc
with cte1 as (select cast(min(change_date) - 1 as date) as earliest_change_date from products), cte2 as (select distinct product_id from products), cte3 as (select product_id, 10 as new_price, earliest_change_date as change_date from cte1 cross join cte2), cte4 as (select * from products union select * from cte3 order by product_id asc, change_date asc), cte5 as (select product_id, new_price, change_date, rank() over (partition by product_id order by change_date desc) as 'ranking' from cte4 where change_date <= '2019-08-16') select product_id, new_price as price from cte5 where ranking = 1 order by product_id asc
with cte1 as (select distinct pd.product_id from products pd), cte2 as (select sub1.product_id, sub1.new_price from (select pd1.product_id, pd1.new_price, pd1.change_date, rank() over(partition by pd1.product_id order by pd1.change_date desc) as changedaterank from Products pd1 where pd1.change_date <= '2019-08-16') sub1 where sub1.changedaterank = 1) select ct1.product_id as product_id, ifnull(ct2.new_price,10) as price from cte1 ct1 left join cte2 ct2 on ct1.product_id = ct2.product_id
with cte1 as (select product_id, new_price as price from (select *, row_number() over (partition by product_id order by change_date desc) as rn from Products where change_date <= '2019-08-16') as cte where rn = 1) select product_id, price from cte1 union select product_id, 10 as price from Products where product_id not in(select product_id from cte1)
with cte1 as( select product_id, new_price, dense_rank() over(partition by product_id order by change_date desc) as 'rk' from Products where change_date <= '2019-08-16'), cte2 as( select distinct p.product_id, coalesce(c1.new_price, 10) as 'price' from Products p left join (select product_id, new_price, rk from cte1 where rk = 1) as c1 on c1.product_id = p.product_id ) select * from cte2
with cte_prod as ( select distinct(product_id) as product_id from products ) select p.product_id, case when new_price IS NULL then 10 else new_price end as price from cte_prod p left join (select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16')x on p.product_id = x.product_id where rnk = 1 or rnk is NULL
with f as ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from products where datediff('2019-08-16',change_date) >= 0 ), f2 as ( select product_id, new_price as price from f where rnk = 1 ) select distinct a.product_id, ifnull(f2.price,10) as price from products a left join f2 on a.product_id = f2.product_id
with filtered (product_id, new_price, change_date) as ( select * from products where change_date <= '2019-08-16'), ranked (product_id, new_price, change_date, date_rank) as ( select *, rank() over (partition by product_id order by change_date desc) as date_rank from filtered ), def (product_id, price) as ( select distinct product_id, 10 from products where product_id not in (select product_id from ranked)) select product_id, new_price as price from ranked where date_rank = 1 union select * from def
with id as ( select distinct product_id from products ), newest_date as ( select *, rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ) select i.product_id, ifnull(n.new_price, 10) as price from id i left join newest_date n on i.product_id = n.product_id and rnk = 1
with last_change as ( select distinct p.product_id, max(p.change_date) over (partition by p.product_id) as last_change_date from products p where p.change_date <= '2019-08-16' ), all_products as ( select distinct p3.product_id, 10 as price from products p3 ) select distinct ap.product_id, Coalesce(p2.new_price, ap.price) as price from last_change l LEFT JOIN products p2 on p2.product_id = l.product_id and p2.change_date = l.last_change_date RIGHT JOIN all_products ap on ap.product_id = p2.product_id
with last_change as(select product_id,max(change_date) as max_date from products where change_date<='2019-08-16' group by product_id), last_price as (select last_change.product_id,last_change.max_date,products.new_price as price from last_change inner join products on last_change.product_id=products.product_id and last_change.max_date = products.change_date), distinct_product as (Select distinct(product_id) from products) select distinct_product.product_id,ifnull(LP.price,10) as price from distinct_product left join last_price LP on distinct_product.product_id=LP.product_id
with main as ( select product_id, new_price, rank() over(partition by product_id order by change_date desc) rnk from products where change_date <= '2019-08-16' ) select distinct p.product_id, coalesce(main.new_price, 10) as price from products p left join main on p.product_id = main.product_id and rnk = 1
with maxed as ( select distinct product_id , first_value(new_price) over (partition by product_id order by change_date desc) as m from Products where change_date<='2019-08-16' ) select distinct Products.product_id, ifnull(m,10) as price from Products left join maxed on Products.product_id = maxed.product_id
with norm_prod as( select distinct product_id from products), max_date as( select product_id, max(change_date) change_date from Products p where p.change_date <= '2019-08-16' group by product_id) select n.product_id, coalesce(p.new_price, 10) price from norm_prod n left join max_date m on n.product_id = m.product_id left join products p on n.product_id = p.product_id and m.change_date = p.change_date
with p1 as (select *, rank() over(partition by product_id order by change_date desc) as lrank from products where change_date <='2019-08-16') select product_id, case when change_date <='2019-08-16' then new_price else 10 end as price from (select product_id, change_date, new_price from p1 where lrank=1 union select product_id, min(change_date) as change_date, null as new_price from products group by product_id having min(change_date>'2019-08-16')) p2
with price_date_rank as ( select product_id, new_price, change_date, rank() over (partition by product_id order by change_date desc) as price_rank from Products where change_date <= '2019-08-16') select p.product_id, ifnull(r.new_price, 10) as price from products p left join price_date_rank r on p.product_id = r.product_id and r.price_rank = 1 group by p.product_id
with prod_rank as(select p.product_id, p.new_price as price, rank() over(partition by p.product_id order by p.change_date desc) as prod_rank from Products p where p.change_date<='2019-08-16' ), prod_rank_one as( select product_id, price from prod_rank where prod_rank=1) select distinct p.product_id, ifnull(pro.price,10) as price from Products p left join prod_rank_one pro on p.product_id = pro.product_id
with product_list as ( select product_id from Products group by product_id ), latest_price as ( select product_id , new_price , row_number() over (partition by product_id order by change_date desc) as rnum from Products where change_date<='2019-08-16' ) select product_id , new_price as price from latest_price where rnum=1 union select distinct product_id , 10 as price from Products where product_id not in ( select product_id from latest_price) order by product_id , price
with product_with_base as ( select * from products where change_date <= '2019-08-16' union select distinct product_id, 10, '2000-01-01' from products ) select product_id, new_price as price from( select *, rank() over(partition by product_id order by change_date desc) as rnk from product_with_base ) tbl where rnk = 1
with s as (select distinct product_id from Products), t as (SELECT *, row_number() over(partition by product_id order by change_date desc) as rw FROM Products WHERE change_date <= '2019-08-16') select s.product_id, ifnull(t.new_price, 10) as price from s left join t on s.product_id = t.product_id and t.rw = 1 order by price desc
with t as ( SELECT product_id, new_price As price FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) As 'rnk' FROM Products WHERE change_date <= '2019-08-16') As t WHERE rnk = 1) SELECT DISTINCT p.product_id, IFNULL(t.price, 10) As price FROM Products p LEFT JOIN t ON p.product_id = t.product_id
with t as ( select *, first_value(new_price) over (partition by product_id order by change_date DESC) as price from Products where change_date <= '2019-08-16') select distinct P.product_id, ifnull(price, 10) as price from t right join Products P on t.product_id = P.product_id order by 2
with t as ( select product_id from products where change_date <= '2019-08-16'), t1 as ( select product_id, new_price, change_date, rank() over (partition by product_id order by change_date desc) as latest_change from products where change_date <= '2019-08-16' ) select product_id, new_price as price from t1 where latest_change=1 union select product_id, 10 as new_price from products where product_id not in (select * from t)
with t as ( select product_id from products where change_date <= '2019-08-16'), t1 as ( select product_id, new_price, change_date, rank() over (partition by product_id order by change_date desc) as latest_change from products where change_date <= '2019-08-16' ) select product_id, new_price as price from t1 where latest_change=1 union select product_id, 10 as new_price from products where product_id not in (select product_id from t1)
with t as ( select product_id, 10 as price, '1970-01-01' as begin_date, min(change_date) as end_date from products group by 1 union all select product_id, new_price as price, change_date as begin_date, lead(change_date) over(partition by product_id order by change_date) as end_date from products ) select product_id, price from t where '2019-08-16' >= begin_date and (end_date is null or '2019-08-16' < end_date) order by 1
with t as ( select product_id, max(change_date) d from products where change_date <= '2019-8-16' group by product_id ) select p.product_id, new_price price from products p join t on p.product_id = t.product_id and p.change_date = t.d union select product_id, 10 price from products where product_id not in (select product_id from t)
with t as ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from products where change_date <= '2019-08-16' ) select distinct products.product_id, case when t.new_price is null then 10 else t.new_price end as price from products left join t on products.product_id=t.product_id and t.rnk=1
with t as (select * ,row_number() over (partition by product_id order by change_date desc) as rn from Products where change_date <= '2019-08-16') select p.product_id, ifnull(t.new_price,10) as price from Products p left join t on p.product_id = t.product_id and rn = 1 group by 1,2
with t as (select product_id ,new_price ,rank() over (partition by product_id order by change_date desc) as price_rank from products where change_date <= date('2019-08-16')) select a.product_id ,case when t.new_price is null then 10 else t.new_price end as price from (select distinct product_id from products) a LEFT JOIN t ON a.product_id = t.product_id and t.price_rank = 1
with t as (select product_id, if(change_date > '2019-08-16', 10, new_price) as new_price, if(change_date > '2019-08-16', '0', change_date) as change_date from products) select distinct t1.product_id, t1.new_price as price from t t1 left join t t2 on t1.product_id = t2.product_id and t1.change_date < t2.change_date where t2.change_date is null
with t as (select product_id, max(change_date) as recent_chg_dt, 'Y' as chg_bf from Products where change_date <= '2019-08-16' group by 1) select p.product_id, p.new_price as price from Products as p join t on p.product_id = t.product_id and p.change_date = t.recent_chg_dt union select product_id, 10 as price from Products where product_id not in (select product_id from t)
with t0 as(select product_id,new_price, to_days(change_date) change_date, to_days( ifnull(lead(change_date)over(partition by product_id order by change_date), if(change_date<=date("2019-08-16"),date("2019-08-17"),change_date)))-1 next_change_date from Products), t1 as (select product_id,new_price price from t0 where to_days("2019-08-16") between change_date and next_change_date or to_days("2019-08-16") = change_date) select product_id, ifnull(price,10) price from t1 right join (select distinct product_id from Products) tmp using(product_id)
with t1 as (select product_id, max(change_date) as latest from products where change_date <= '2019-08-16' group by 1), t2 as (select product_id, new_price as price from products where (product_id, change_date) in (select * from t1)) select a.product_id, ifnull(t2.price, 10) as price from (select distinct product_id from products) a left join t2 on a.product_id = t2.product_id
with t1 as (select product_id, min(change_date) as first_date from Products group by 1) select product_id, new_price as price from (select t1.product_id, t2.new_price, rank()over(partition by t2.product_id order by t2.change_date desc) as date_rank from t1 inner join Products t2 on t1.first_date <= "2019-08-16" AND t1.product_id=t2.product_id AND t2.change_date <= "2019-08-16") t3 where date_rank=1 union select product_id, price from (select t1.product_id, 10 as price, rank()over(partition by t2.product_id order by t2.change_date asc) as date_rank from t1 inner join Products t2 on t1.first_date > "2019-08-16" AND t1.product_id=t2.product_id) t4 where date_rank=1 order by product_id
with t1 as( select p.product_id as product_id, p.new_price as price from Products p left join (select product_id, max(change_date) as latest from Products where change_date <= date('2019-08-16') group by product_id) t on p.product_id =t.product_id and p.change_date=t.latest where t.product_id is not null ), t2 as( select product_id from Products group by product_id ) select t2.product_id, coalesce(t1.price,10) as price from t2 left join t1 on t2.product_id=t1.product_id order by t2.product_id
with table_1 as ( select product_id from products group by product_id ), table_2 as ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rk from products where change_date <= '2019-08-16' ) select t1.product_id, coalesce(t2.price,10) as price from table_1 t1 left join (select product_id, new_price as price from table_2 where rk = 1) t2 on t1.product_id = t2.product_id
with tb1 as ( select distinct product_id from Products ), tb2 as ( select p1.product_id, max(p1.change_date) as maxDate from Products as p1 where p1.change_date <= 20190816 group by p1.product_id ), tb3 as ( select tb2.product_id, tb2.maxDate, p2.new_price from Products as p2 join tb2 on p2.change_date = tb2.maxDate and p2.product_id = tb2.product_id ) select tb1.product_id, if(isNull(tb3.maxDate), 10, tb3.new_price) as price from tb1 left join tb3 on tb1.product_id = tb3.product_id
with tem as (select * from products where change_date <= '2019-08-16') select product_id, new_price as price from ( select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rank_n from tem)a where rank_n=1 union select product_id, 10 as price from ( select product_id, min(change_date) as min_date from products group by product_id) a where min_date > '2019-08-16'
with temp as ( select * , row_number() over (partition by product_id order by change_date desc) as rn from products p where change_date <= '2019-08-16' ) select distinct p.product_id , coalesce(t.new_price, 10) as price from products p left join temp t on p.product_id = t.product_id and t.rn = 1
with temp as ( select * from ( select *, row_number() over (partition by product_id order by change_date desc) as rn from products where change_date <= "2019-08-16")t1 where rn = 1) select distinct p.product_id,coalesce(t.new_price,10) as price from products p left join temp t on p.product_id = t.product_id
with temp as ( select * from (select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rnk from (select * from Products where change_date <='2019-08-16') p) m where m.rnk=1), cte as ( select product_id from Products group by product_id ) select c.product_id as product_id, if(t.new_price is null, 10, t.new_price) as price from cte c left join temp t on t.product_id=c.product_id
with temp as ( select product_id, ifnull(new_price, 10) as new_price, ifnull(change_date, '2019-08-16') as change_date from (select distinct product_id from products) as p1 left join (select * from products where change_date <= '2019-08-16') as p2 using (product_id)) select product_id, new_price as price from temp where (product_id, change_date) in (select product_id, max(change_date) from temp group by product_id)
with temp as ( select product_id, new_price, rank() over(partition by product_id order by change_date desc) as rk from products where change_date <= '2019-08-16' ) select distinct p.product_id, (case when t.new_price is null then 10 else t.new_price end) as price from products p left join temp t on p.product_id = t.product_id and rk=1
with temp as ( select product_id, new_price, rank()over(partition by product_id order by change_date desc) as rk from products where change_date<='2019-08-16' ) select product_id, new_price as price from temp where rk = 1 union select product_id, 10 as price from products group by 1 having min(change_date)> '2019-08-16'
with temp as (select *, rank() over(partition by product_id order by change_date desc) rnk from Products where change_date <= '2019-08-16') select product_id, new_price price from temp where rnk = 1 union select product_id, 10 price from Products where product_id not in (select product_id from Products where change_date<='2019-08-16')
with temp as (select n.product_id, n.new_price as price from( select new.product_id, new.new_price, rank() over(partition by new.product_id order by new.days asc) as r from ( select *, @temp := '2019-08-16' as d, datediff(@temp, change_date) as days from products) new where new.days >= 0) n where r = 1) select product_id, 10 as price from products where product_id not in (select product_id from temp) union select * from temp order by product_id asc
with temp as (select product_id, new_price from ( select product_id, new_price, change_date, (rank() over(partition by product_id order by change_date desc)) as rank_date from products where change_date <= '2019-08-16' ) as new_price_table where rank_date = 1 ) select distinct p.product_id, ifnull(temp.new_price,10) as price from products p left join temp on p.product_id = temp.product_id order by 1
with temp as (select product_id, new_price price, rank() over (partition by product_id order by change_date desc) myrank from products where change_date <= '2019-08-16') select product_id, price from temp where myrank=1 group by product_id union all select product_id, 10 as price from products where product_id not in (select product_id from temp group by product_id) group by product_id
with temp as (select product_id, new_price, rank() over (partition by product_id order by change_date desc) as rnk from Products where change_date <='2019-08-16') select distinct p.product_id, case when t.new_price is null then 10 else t.new_price end as price from Products p left join temp t on p.product_id=t.product_id and rnk=1
with temp as( select product_id, new_price from ( select product_id, new_price, change_date, (rank() over(partition by product_id order by change_date desc)) as rnk_date from Products where change_date <= '2019-08-16') as new_price_table where rnk_date=1) select distinct p.product_id, ifnull(temp.new_price,10) as price from Products p left join temp on p.product_id=temp.product_id order by 1
with temp(product_id, price, rk) as (select product_id, new_price as price, dense_rank() over (partition by product_id order by change_date desc ) as rk from Products p where change_date <='2019-08-16' ) select distinct product_id, price from temp where rk=1 union select distinct product_id, 10 as price from products where product_id not in (select product_id from temp )
with tmp as ( select *, row_number() over(partition by product_id order by change_date desc) as rn from products where change_date <= '2019-08-16' ) select product_id, new_price as price from tmp where rn = 1 union select product_id, 10 as price from products group by product_id having min(change_date) > '2019-08-16'
with tmp as (select *, rank() over (partition by product_id order by change_date desc) as rnk from products where change_date<='2019-08-16' ) select a.product_id, ifnull(new_price,10) as price from (select distinct product_id from products) a left join (select * from tmp where rnk=1) b on a.product_id=b.product_id
with tmp as(select * from (select product_id,new_price,row_number() over (partition by product_id order by diff asc)m from (select product_id, change_date,new_price, DATEDIFF("2019-08-16", change_date) diff, row_number() over (partition by product_id order by change_date desc)rk from products where change_date<='2019-08-16')t )t1 where m=1) select p.product_id ,coalesce(t.new_price,10) price from (select distinct product_id from products) p left join tmp t on p.product_id=t.product_id
with uniq_table AS ( SELECT distinct (product_id) FROM Products ), temp_table AS ( SELECT p1.product_id, p1.new_price as price, p1.change_date, DENSE_RANK() OVER ( PARTITION BY p1.product_id ORDER BY p1.change_date DESC) as row_rank FROM Products as p1 WHERE p1.change_date <= '2019-08-16' ORDER BY p1.product_id,p1.change_date DESC ), temp_table_2 AS ( SELECT un.product_id, IFNULL(temp.price,10) as price, DENSE_RANK () OVER (PARTITION BY temp.product_id ORDER BY temp.row_rank) as new_rank FROM uniq_table as un LEFT OUTER JOIN temp_table as temp ON un.product_id = temp.product_id ORDER BY temp.price DESC ) SELECT product_id, price FROM temp_table_2 WHERE new_rank = 1
with updated_price as ( select product_id, new_price as price from ( select *, rank() over(partition by product_id order by change_date desc) as r from products where change_date <= '2019-08-16' ) tmp where r = 1 ) select distinct p.product_id, ifnull(price, 10) as price from products p left join updated_price u on p.product_id = u.product_id
with x as (select distinct product_id from products), y as (select product_id, new_price as price, rank() over(partition by product_id order by change_date desc) as rank1 from products where change_date<='2019-08-16'), z as (select product_id,price from y where rank1=1) select x.product_id, coalesce(z.price,10) as price from x left join z on x.product_id=z.product_id
